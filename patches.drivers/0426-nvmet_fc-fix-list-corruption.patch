From: James Smart <jsmart2021@gmail.com>
Date: Fri, 26 May 2017 13:17:27 -0700
Subject: nvmet_fc: fix list corruption
Patch-mainline: Never, SUSE specific backport
References: bsc#1040701

The per-cpu work structures are selected by cpu number.  If the
lldd sets its number of hw_queues to 1, meaning there's a single
isr handler, the transport sets cpu to UNBOUNDED for workqueue
scheduling. However, the same cpu value is used as an index to
select the cpu work structure. UNBOUNDED ends up being NR_CPUS
which can be larger than the number of active cpus. Which means,
when hw_queues was set to 1 we could end up indexing beyond our
array and using/corrupting bad memory.

This shows itself as:
1) a NULL lock structure to _raw_spin_lock_irqsave called by
  nvmet_fc_rcv_fcp_req()
2) illegal list_add or list_del called by nvmet_fc_rcv_fcp_req(),
  nvmet_fc_xmt_fcp_op_done(), or nvmet_fc_do_work_on_cpu();

Correct by catching the cpu reference when getting the structure
address. Also ensure queue id indexing for the assoction is within
range for the association.

Signed-off-by: Dick Kennedy <dick.kennedy@broadcom.com>
Signed-off-by: James Smart <james.smart@broadcom.com>
Acked-by: Johannes Thumshirn <jthumshirn@suse.de>
---
 drivers/nvme/target/fc.c | 13 ++++++++++++-
 1 file changed, 12 insertions(+), 1 deletion(-)

diff --git a/drivers/nvme/target/fc.c b/drivers/nvme/target/fc.c
index 9adfdba2a537..d6df3a9d1403 100644
--- a/drivers/nvme/target/fc.c
+++ b/drivers/nvme/target/fc.c
@@ -230,7 +230,15 @@ static DEFINE_IDA(nvmet_fc_tgtport_cnt);
 
 static u32 nvmet_fc_cpu_cnt;
 static DEFINE_PER_CPU(struct nvmet_fc_work_by_cpu, nvmet_fc_cpu_workcpu);
-#define nvmet_fc_workcpu(cpu)	(&per_cpu(nvmet_fc_cpu_workcpu, cpu))
+
+static inline struct nvmet_fc_work_by_cpu *
+nvmet_fc_workcpu(int cpu)
+{
+	if (cpu == WORK_CPU_UNBOUND)
+		cpu = get_cpu();
+
+	return per_cpu_ptr(&nvmet_fc_cpu_workcpu, cpu % nvmet_fc_cpu_cnt);
+}
 
 static void nvmet_fc_handle_ls_rqst_work(struct work_struct *work);
 static void nvmet_fc_tgt_a_put(struct nvmet_fc_tgt_assoc *assoc);
@@ -706,6 +714,9 @@ nvmet_fc_find_target_queue(struct nvmet_fc_tgtport *tgtport,
 	u16 qid = nvmet_fc_getqueueid(connection_id);
 	unsigned long flags;
 
+	if (qid >= NVMET_NR_QUEUES)
+		return NULL;
+
 	spin_lock_irqsave(&tgtport->lock, flags);
 	list_for_each_entry(assoc, &tgtport->assoc_list, a_list) {
 		if (association_id == assoc->association_id) {
-- 
2.11.0

