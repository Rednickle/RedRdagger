From: Satish Kharat <satishkh@cisco.com>
Date: Thu, 5 Oct 2017 16:41:21 -0700
Subject: scsi: libfc: fix a deadlock in fc_rport_work
Patch-mainline: Queued in subsystem maintainer repository
Git-repo: git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi.git
Git-commit: d1b3f51ee1eab3a6db1b09a60e61280c48eb0b01
References: bsc#1063695

In places like fc_rport_recv_plogi_req and fcoe_ctlr_vn_add we always
take the lport disc_mutex lock before the rports mutex
(rp_mutex) lock. Gaurding list_del_rcu(&rdata->peers) with
disc.disc_mutex in fc_rport_work is correct but the rp_mutex lock
can and should to be dropped before taking that lock else results
in a deadlock.

Signed-off-by: Satish Kharat <satishkh@cisco.com>
Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
---
 drivers/scsi/libfc/fc_rport.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/drivers/scsi/libfc/fc_rport.c b/drivers/scsi/libfc/fc_rport.c
index 520325867e2b..31d31aad3de1 100644
--- a/drivers/scsi/libfc/fc_rport.c
+++ b/drivers/scsi/libfc/fc_rport.c
@@ -383,11 +383,11 @@ static void fc_rport_work(struct work_struct *work)
 				fc_rport_enter_flogi(rdata);
 				mutex_unlock(&rdata->rp_mutex);
 			} else {
+				mutex_unlock(&rdata->rp_mutex);
 				FC_RPORT_DBG(rdata, "work delete\n");
 				mutex_lock(&lport->disc.disc_mutex);
 				list_del_rcu(&rdata->peers);
 				mutex_unlock(&lport->disc.disc_mutex);
-				mutex_unlock(&rdata->rp_mutex);
 				kref_put(&rdata->kref, fc_rport_destroy);
 			}
 		} else {
-- 
2.12.3

