From: Mitch Williams <mitch.a.williams@intel.com>
Date: Mon, 19 Jun 2017 16:41:46 -0700
Subject: i40e: add private flag to control source pruning
Patch-mainline: Not yet, testing
References: bsc#1034075

TEST PATCH

By default, our devices do source pruning, that is, they drop receive
packets that have the source MAC matching one of the receive filters.
Unfortunately, this breaks ARP monitoring in channel bonding, as the
bonding driver expects devices to receive ARPs containing their own
source address.

Add an ethtool private flag to control this feature.

Also, remove the netif_running() check when we process our private
flags. It's OK to reset when the device is closed and in most cases we
need the reset the apply these changes.

Signed-off-by: Mitch Williams <mitch.a.williams@intel.com>
Acked-by: Michal Kubecek <mkubecek@suse.cz>
---
 drivers/net/ethernet/intel/i40e/i40e.h         |    2 ++
 drivers/net/ethernet/intel/i40e/i40e_ethtool.c |   13 +++++++++++++
 drivers/net/ethernet/intel/i40e/i40e_main.c    |   25 +++++++++++++++++++++++++
 3 files changed, 40 insertions(+)

--- a/drivers/net/ethernet/intel/i40e/i40e.h
+++ b/drivers/net/ethernet/intel/i40e/i40e.h
@@ -105,6 +105,7 @@
 #define I40E_PRIV_FLAGS_VEB_STATS		BIT(3)
 #define I40E_PRIV_FLAGS_HW_ATR_EVICT		BIT(4)
 #define I40E_PRIV_FLAGS_TRUE_PROMISC_SUPPORT	BIT(5)
+#define I40E_PRIV_FLAGS_SOURCE_PRUNING_DISABLED	BIT(6)
 
 #define I40E_NVM_VERSION_LO_SHIFT	0
 #define I40E_NVM_VERSION_LO_MASK	(0xff << I40E_NVM_VERSION_LO_SHIFT)
@@ -351,6 +352,7 @@ struct i40e_pf {
 #define I40E_FLAG_PTP_L4_CAPABLE		BIT_ULL(53)
 #define I40E_FLAG_WOL_MC_MAGIC_PKT_WAKE		BIT_ULL(54)
 #define I40E_FLAG_TEMP_LINK_POLLING		BIT_ULL(55)
+#define I40E_FLAG_SOURCE_PRUNING_DISABLED	BIT_ULL(59)
 
 	/* tracks features that get auto disabled by errors */
 	u64 auto_disable_flags;
--- a/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_ethtool.c
@@ -234,6 +234,7 @@ static const char i40e_priv_flags_string
 	"flow-director-atr",
 	"veb-stats",
 	"hw-atr-eviction",
+	"disable-source-pruning",
 };
 
 #define I40E_PRIV_FLAGS_STR_LEN ARRAY_SIZE(i40e_priv_flags_strings)
@@ -3060,6 +3061,8 @@ static u32 i40e_get_priv_flags(struct ne
 		ret_flags |= pf->flags & I40E_FLAG_TRUE_PROMISC_SUPPORT ?
 			I40E_PRIV_FLAGS_TRUE_PROMISC_SUPPORT : 0;
 	}
+	ret_flags |= pf->flags & I40E_FLAG_SOURCE_PRUNING_DISABLED ?
+		I40E_PRIV_FLAGS_SOURCE_PRUNING_DISABLED : 0;
 
 	return ret_flags;
 }
@@ -3143,6 +3146,16 @@ static int i40e_set_priv_flags(struct ne
 	else
 		pf->auto_disable_flags |= I40E_FLAG_HW_ATR_EVICT_CAPABLE;
 
+	if ((flags & I40E_PRIV_FLAGS_SOURCE_PRUNING_DISABLED) &&
+	    !(pf->flags & I40E_FLAG_SOURCE_PRUNING_DISABLED)) {
+		pf->flags |= I40E_FLAG_SOURCE_PRUNING_DISABLED;
+		reset_required = true;
+	} else if (!(flags & I40E_PRIV_FLAGS_SOURCE_PRUNING_DISABLED) &&
+		   (pf->flags & I40E_FLAG_SOURCE_PRUNING_DISABLED)) {
+		pf->flags &= ~I40E_FLAG_SOURCE_PRUNING_DISABLED;
+		reset_required = true;
+	}
+
 	/* if needed, issue reset to cause things to take effect */
 	if (reset_required)
 		i40e_do_reset(pf, BIT(__I40E_PF_RESET_REQUESTED));
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@ -9673,6 +9673,31 @@ static int i40e_add_vsi(struct i40e_vsi
 
 		enabled_tc = i40e_pf_get_tc_map(pf);
 
+		/* Source pruning is enabled by default, so the flag is
+		 * negative logic - if it's set, we need to fiddle with
+		 * the VSI to disable source pruning.
+		 */
+		if (pf->flags & I40E_FLAG_SOURCE_PRUNING_DISABLED) {
+			memset(&ctxt, 0, sizeof(ctxt));
+			ctxt.seid = pf->main_vsi_seid;
+			ctxt.pf_num = pf->hw.pf_id;
+			ctxt.vf_num = 0;
+			ctxt.info.valid_sections |=
+			     cpu_to_le16(I40E_AQ_VSI_PROP_SWITCH_VALID);
+			ctxt.info.switch_id =
+				   cpu_to_le16(I40E_AQ_VSI_SW_ID_FLAG_LOCAL_LB);
+			ret = i40e_aq_update_vsi_params(hw, &ctxt, NULL);
+			if (ret) {
+				dev_info(&pf->pdev->dev,
+					 "update vsi failed, err %s aq_err %s\n",
+					 i40e_stat_str(&pf->hw, ret),
+					 i40e_aq_str(&pf->hw,
+						    pf->hw.aq.asq_last_status));
+				ret = -ENOENT;
+				goto err;
+			}
+		}
+
 		/* MFP mode setup queue map and update VSI */
 		if ((pf->flags & I40E_FLAG_MFP_ENABLED) &&
 		    !(pf->hw.func_caps.iscsi)) { /* NIC type PF */
