From: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Date: Tue, 20 Feb 2018 17:42:50 -0500
Subject: drm/amd/display: define DC_LOGGER for logger
Git-commit: 1296423bf23c7a58133970e223b1f47ec6570308
Patch-mainline: v4.17-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

Created a DC_LOGGER define. This is used to
pass the logger into the macros.

Anywhere we need to use the logger we need to define
DC_LOGGER

Signed-off-by: Bhawanpreet Lakha <Bhawanpreet.Lakha@amd.com>
Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/amd/display/dc/bios/bios_parser.c                   |    6 
 drivers/gpu/drm/amd/display/dc/bios/command_table2.c                |   11 -
 drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c                    |   11 -
 drivers/gpu/drm/amd/display/dc/core/dc.c                            |   11 -
 drivers/gpu/drm/amd/display/dc/core/dc_link.c                       |   53 +++----
 drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c                    |   53 ++-----
 drivers/gpu/drm/amd/display/dc/core/dc_resource.c                   |    7 -
 drivers/gpu/drm/amd/display/dc/dce/dce_abm.c                        |    5 
 drivers/gpu/drm/amd/display/dc/dce/dce_audio.c                      |   17 +-
 drivers/gpu/drm/amd/display/dc/dce/dce_clock_source.c               |   32 ++--
 drivers/gpu/drm/amd/display/dc/dce/dce_clocks.c                     |    8 -
 drivers/gpu/drm/amd/display/dc/dce/dce_link_encoder.c               |   22 +--
 drivers/gpu/drm/amd/display/dc/dce/dce_stream_encoder.c             |    7 -
 drivers/gpu/drm/amd/display/dc/dce/dce_transform.c                  |   11 -
 drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c           |   14 --
 drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c         |   20 +-
 drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c             |    6 
 drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c   |   17 +-
 drivers/gpu/drm/amd/display/dc/dce110/dce110_transform_v.c          |    5 
 drivers/gpu/drm/amd/display/dc/dce112/dce112_compressor.c           |   11 -
 drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c             |    5 
 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hubbub.c                 |   68 +++-------
 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c           |   21 +--
 drivers/gpu/drm/amd/display/dc/i2caux/aux_engine.c                  |    6 
 drivers/gpu/drm/amd/display/dc/i2caux/dce110/i2c_hw_engine_dce110.c |    6 
 drivers/gpu/drm/amd/display/dc/irq/dce110/irq_service_dce110.c      |   11 -
 drivers/gpu/drm/amd/display/dc/irq/irq_service.c                    |   10 -
 drivers/gpu/drm/amd/display/include/logger_types.h                  |   64 ++++-----
 28 files changed, 230 insertions(+), 288 deletions(-)

--- a/drivers/gpu/drm/amd/display/dc/bios/bios_parser.c
+++ b/drivers/gpu/drm/amd/display/dc/bios/bios_parser.c
@@ -49,6 +49,9 @@
 
 #define LAST_RECORD_TYPE 0xff
 
+#define DC_LOGGER \
+	bp->base.ctx->logger
+
 /* GUID to validate external display connection info table (aka OPM module) */
 static const uint8_t ext_display_connection_guid[NUMBER_OF_UCHAR_FOR_GUID] = {
 	0x91, 0x6E, 0x57, 0x09,
@@ -3079,8 +3082,7 @@ static enum bp_result patch_bios_image_f
 					    opm_object,
 					    &ext_display_connection_info_tbl) != BP_RESULT_OK) {
 
-		DC_LOG_WARNING(bp->base.ctx->logger,
-				"%s: Failed to read Connection Info Table", __func__);
+		DC_LOG_WARNING("%s: Failed to read Connection Info Table", __func__);
 		return BP_RESULT_UNSUPPORTED;
 	}
 
--- a/drivers/gpu/drm/amd/display/dc/bios/command_table2.c
+++ b/drivers/gpu/drm/amd/display/dc/bios/command_table2.c
@@ -34,6 +34,8 @@
 #include "command_table_helper2.h"
 #include "bios_parser_helper.h"
 #include "bios_parser_types_internal2.h"
+#define DC_LOGGER \
+	bp->base.ctx->logger
 
 #define GET_INDEX_INTO_MASTER_TABLE(MasterOrData, FieldName)\
 	(((char *)(&((\
@@ -239,8 +241,7 @@ static enum bp_result transmitter_contro
 	if (cntl->action == TRANSMITTER_CONTROL_ENABLE ||
 		cntl->action == TRANSMITTER_CONTROL_ACTIAVATE ||
 		cntl->action == TRANSMITTER_CONTROL_DEACTIVATE) {
-		DC_LOG_BIOS(bp->base.ctx->logger, \
-		"%s:ps.param.symclk_10khz = %d\n",\
+		DC_LOG_BIOS("%s:ps.param.symclk_10khz = %d\n",\
 		__func__, ps.param.symclk_10khz);
 	}
 
@@ -331,8 +332,7 @@ static enum bp_result set_pixel_clock_v7
 			(uint8_t) bp->cmd_helper->
 				transmitter_color_depth_to_atom(
 					bp_params->color_depth);
-		DC_LOG_BIOS(bp->base.ctx->logger, \
-				"%s:program display clock = %d"\
+		DC_LOG_BIOS("%s:program display clock = %d"\
 				"colorDepth = %d\n", __func__,\
 				bp_params->target_pixel_clock, bp_params->color_depth);
 
@@ -772,8 +772,7 @@ static enum bp_result set_dce_clock_v2_1
 		 */
 		params.param.dceclk_10khz = cpu_to_le32(
 				bp_params->target_clock_frequency / 10);
-	DC_LOG_BIOS(bp->base.ctx->logger,
-			"%s:target_clock_frequency = %d"\
+	DC_LOG_BIOS("%s:target_clock_frequency = %d"\
 			"clock_type = %d \n", __func__,\
 			bp_params->target_clock_frequency,\
 			bp_params->clock_type);
--- a/drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c
+++ b/drivers/gpu/drm/amd/display/dc/calcs/dcn_calcs.c
@@ -33,6 +33,8 @@
 #include "dcn10/dcn10_resource.h"
 #include "dcn_calc_math.h"
 
+#define DC_LOGGER \
+	dc->ctx->logger
 /*
  * NOTE:
  *   This file is gcc-parseable HW gospel, coming straight from HW engineers.
@@ -1242,8 +1244,7 @@ unsigned int dcn_find_dcfclk_suits_all(
 	else
 		dcf_clk =  dc->dcn_soc->dcfclkv_min0p65*1000;
 
-	DC_LOG_BANDWIDTH_CALCS(dc->ctx->logger,
-		"\tdcf_clk for voltage = %d\n", dcf_clk);
+	DC_LOG_BANDWIDTH_CALCS("\tdcf_clk for voltage = %d\n", dcf_clk);
 	return dcf_clk;
 }
 
@@ -1441,8 +1442,7 @@ void dcn_bw_notify_pplib_of_wm_ranges(st
 void dcn_bw_sync_calcs_and_dml(struct dc *dc)
 {
 	kernel_fpu_begin();
-	DC_LOG_BANDWIDTH_CALCS(dc->ctx->logger,
-			"sr_exit_time: %d ns\n"
+	DC_LOG_BANDWIDTH_CALCS("sr_exit_time: %d ns\n"
 			"sr_enter_plus_exit_time: %d ns\n"
 			"urgent_latency: %d ns\n"
 			"write_back_latency: %d ns\n"
@@ -1510,8 +1510,7 @@ void dcn_bw_sync_calcs_and_dml(struct dc
 			dc->dcn_soc->vmm_page_size,
 			dc->dcn_soc->dram_clock_change_latency * 1000,
 			dc->dcn_soc->return_bus_width);
-	DC_LOG_BANDWIDTH_CALCS(dc->ctx->logger,
-			"rob_buffer_size_in_kbyte: %d\n"
+	DC_LOG_BANDWIDTH_CALCS("rob_buffer_size_in_kbyte: %d\n"
 			"det_buffer_size_in_kbyte: %d\n"
 			"dpp_output_buffer_pixels: %d\n"
 			"opp_output_buffer_lines: %d\n"
--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -51,6 +51,8 @@
 #include "dm_helpers.h"
 #include "mem_input.h"
 #include "hubp.h"
+#define DC_LOGGER \
+	dc->ctx->logger
 
 
 /*******************************************************************************
@@ -264,7 +266,7 @@ bool dc_stream_configure_crc(struct dc *
 	/* Only call if supported */
 	if (tg->funcs->configure_crc)
 		return tg->funcs->configure_crc(tg, &param);
-	DC_LOG_WARNING(dc->ctx->logger,  "CRC capture not supported.");
+	DC_LOG_WARNING("CRC capture not supported.");
 	return false;
 }
 
@@ -297,7 +299,7 @@ bool dc_stream_get_crc(struct dc *dc, st
 
 	if (tg->funcs->get_crc)
 		return tg->funcs->get_crc(tg, r_cr, g_y, b_cb);
-	DC_LOG_WARNING(dc->ctx->logger,  "CRC capture not supported.");
+	DC_LOG_WARNING("CRC capture not supported.");
 	return false;
 }
 
@@ -618,8 +620,7 @@ struct dc *dc_create(const struct dc_ini
 
 	dc->config = init_params->flags;
 
-	DC_LOG_DC(dc->ctx->logger,
-			"Display Core initialized\n");
+	DC_LOG_DC("Display Core initialized\n");
 
 
 	/* TODO: missing feature to be enabled */
@@ -888,7 +889,7 @@ bool dc_commit_state(struct dc *dc, stru
 	if (false == context_changed(dc, context))
 		return DC_OK;
 
-	DC_LOG_DC(dc->ctx->logger,  "%s: %d streams\n",
+	DC_LOG_DC("%s: %d streams\n",
 				__func__, context->stream_count);
 
 	for (i = 0; i < context->stream_count; i++) {
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link.c
@@ -45,9 +45,11 @@
 #include "dce/dce_11_0_d.h"
 #include "dce/dce_11_0_enum.h"
 #include "dce/dce_11_0_sh_mask.h"
+#define DC_LOGGER \
+	dc_ctx->logger
 
 #define LINK_INFO(...) \
-	DC_LOG_HW_HOTPLUG(dc_ctx->logger,  \
+	DC_LOG_HW_HOTPLUG(  \
 		__VA_ARGS__)
 
 /*******************************************************************************
@@ -677,12 +679,10 @@ bool dc_link_detect(struct dc_link *link
 
 		switch (edid_status) {
 		case EDID_BAD_CHECKSUM:
-			DC_LOG_ERROR(link->ctx->logger,
-				"EDID checksum invalid.\n");
+			DC_LOG_ERROR("EDID checksum invalid.\n");
 			break;
 		case EDID_NO_RESPONSE:
-			DC_LOG_ERROR(link->ctx->logger,
-				"No EDID read.\n");
+			DC_LOG_ERROR("No EDID read.\n");
 		default:
 			break;
 		}
@@ -712,8 +712,7 @@ bool dc_link_detect(struct dc_link *link
 					"%s: [Block %d] ", sink->edid_caps.display_name, i);
 		}
 
-		DC_LOG_DETECTION_EDID_PARSER(link->ctx->logger,
-			"%s: "
+		DC_LOG_DETECTION_EDID_PARSER("%s: "
 			"manufacturer_id = %X, "
 			"product_id = %X, "
 			"serial_number = %X, "
@@ -733,8 +732,7 @@ bool dc_link_detect(struct dc_link *link
 			sink->edid_caps.audio_mode_count);
 
 		for (i = 0; i < sink->edid_caps.audio_mode_count; i++) {
-			DC_LOG_DETECTION_EDID_PARSER(link->ctx->logger,
-				"%s: mode number = %d, "
+			DC_LOG_DETECTION_EDID_PARSER("%s: mode number = %d, "
 				"format_code = %d, "
 				"channel_count = %d, "
 				"sample_rate = %d, "
@@ -984,8 +982,7 @@ static bool construct(
 		}
 		break;
 	default:
-		DC_LOG_WARNING(dc_ctx->logger,
-			"Unsupported Connector type:%d!\n", link->link_id.id);
+		DC_LOG_WARNING("Unsupported Connector type:%d!\n", link->link_id.id);
 		goto create_fail;
 	}
 
@@ -1138,7 +1135,7 @@ static void dpcd_configure_panel_mode(
 {
 	union dpcd_edp_config edp_config_set;
 	bool panel_mode_edp = false;
-
+	struct dc_context *dc_ctx = link->ctx;
 	memset(&edp_config_set, '\0', sizeof(union dpcd_edp_config));
 
 	if (DP_PANEL_MODE_DEFAULT != panel_mode) {
@@ -1175,8 +1172,7 @@ static void dpcd_configure_panel_mode(
 			ASSERT(result == DDC_RESULT_SUCESSFULL);
 		}
 	}
-	DC_LOG_DETECTION_DP_CAPS(link->ctx->logger,
-			"Link: %d eDP panel mode supported: %d "
+	DC_LOG_DETECTION_DP_CAPS("Link: %d eDP panel mode supported: %d "
 			"eDP panel mode enabled: %d \n",
 			link->link_index,
 			link->dpcd_caps.panel_mode_edp,
@@ -1954,6 +1950,7 @@ bool dc_link_set_backlight_level(const s
 	struct dc  *core_dc = link->ctx->dc;
 	struct abm *abm = core_dc->res_pool->abm;
 	struct dmcu *dmcu = core_dc->res_pool->dmcu;
+	struct dc_context *dc_ctx = link->ctx;
 	unsigned int controller_id = 0;
 	bool use_smooth_brightness = true;
 	int i;
@@ -1965,8 +1962,7 @@ bool dc_link_set_backlight_level(const s
 
 	use_smooth_brightness = dmcu->funcs->is_dmcu_initialized(dmcu);
 
-	DC_LOG_BACKLIGHT(link->ctx->logger,
-			"New Backlight level: %d (0x%X)\n", level, level);
+	DC_LOG_BACKLIGHT("New Backlight level: %d (0x%X)\n", level, level);
 
 	if (dc_is_embedded_signal(link->connector_signal)) {
 		if (stream != NULL) {
@@ -2133,6 +2129,7 @@ static enum dc_status allocate_mst_paylo
 	struct fixed31_32 avg_time_slots_per_mtp;
 	struct fixed31_32 pbn;
 	struct fixed31_32 pbn_per_slot;
+	struct dc_context *dc_ctx = link->ctx;
 	uint8_t i;
 
 	/* enable_link_dp_mst already check link->enabled_stream_count
@@ -2150,21 +2147,18 @@ static enum dc_status allocate_mst_paylo
 					link, pipe_ctx->stream_res.stream_enc, &proposed_table);
 	}
 	else
-		DC_LOG_WARNING(link->ctx->logger,
-				"Failed to update"
+		DC_LOG_WARNING("Failed to update"
 				"MST allocation table for"
 				"pipe idx:%d\n",
 				pipe_ctx->pipe_idx);
 
-	DC_LOG_MST(link->ctx->logger,
-			"%s  "
+	DC_LOG_MST("%s  "
 			"stream_count: %d: \n ",
 			__func__,
 			link->mst_stream_alloc_table.stream_count);
 
 	for (i = 0; i < MAX_CONTROLLER_NUM; i++) {
-		DC_LOG_MST(link->ctx->logger,
-		"stream_enc[%d]: 0x%x      "
+		DC_LOG_MST("stream_enc[%d]: 0x%x      "
 		"stream[%d].vcp_id: %d      "
 		"stream[%d].slot_count: %d\n",
 		i,
@@ -2215,6 +2209,7 @@ static enum dc_status deallocate_mst_pay
 	struct fixed31_32 avg_time_slots_per_mtp = dal_fixed31_32_from_int(0);
 	uint8_t i;
 	bool mst_mode = (link->type == dc_connection_mst_branch);
+	struct dc_context *dc_ctx = link->ctx;
 
 	/* deallocate_mst_payload is called before disable link. When mode or
 	 * disable/enable monitor, new stream is created which is not in link
@@ -2240,23 +2235,20 @@ static enum dc_status deallocate_mst_pay
 				link, pipe_ctx->stream_res.stream_enc, &proposed_table);
 		}
 		else {
-				DC_LOG_WARNING(link->ctx->logger,
-						"Failed to update"
+				DC_LOG_WARNING("Failed to update"
 						"MST allocation table for"
 						"pipe idx:%d\n",
 						pipe_ctx->pipe_idx);
 		}
 	}
 
-	DC_LOG_MST(link->ctx->logger,
-			"%s"
+	DC_LOG_MST("%s"
 			"stream_count: %d: ",
 			__func__,
 			link->mst_stream_alloc_table.stream_count);
 
 	for (i = 0; i < MAX_CONTROLLER_NUM; i++) {
-		DC_LOG_MST(link->ctx->logger,
-		"stream_enc[%d]: 0x%x      "
+		DC_LOG_MST("stream_enc[%d]: 0x%x      "
 		"stream[%d].vcp_id: %d      "
 		"stream[%d].slot_count: %d\n",
 		i,
@@ -2290,7 +2282,7 @@ void core_link_enable_stream(
 		struct pipe_ctx *pipe_ctx)
 {
 	struct dc  *core_dc = pipe_ctx->stream->ctx->dc;
-
+	struct dc_context *dc_ctx = pipe_ctx->stream->ctx;
 	enum dc_status status;
 
 	/* eDP lit up by bios already, no need to enable again. */
@@ -2307,8 +2299,7 @@ void core_link_enable_stream(
 	status = enable_link(state, pipe_ctx);
 
 	if (status != DC_OK) {
-			DC_LOG_WARNING(pipe_ctx->stream->ctx->logger,
-			 "enabling link %u failed: %d\n",
+			DC_LOG_WARNING("enabling link %u failed: %d\n",
 			pipe_ctx->stream->sink->link->link_index,
 			status);
 
--- a/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_link_dp.c
@@ -11,6 +11,8 @@
 #include "dpcd_defs.h"
 
 #include "resource.h"
+#define DC_LOGGER \
+	link->ctx->logger
 
 /* maximum pre emphasis level allowed for each voltage swing level*/
 static const enum dc_pre_emphasis voltage_swing_to_pre_emphasis[] = {
@@ -63,8 +65,7 @@ static void wait_for_training_aux_rd_int
 
 	udelay(default_wait_in_micro_secs);
 
-	DC_LOG_HW_LINK_TRAINING(link->ctx->logger,
-		"%s:\n wait = %d\n",
+	DC_LOG_HW_LINK_TRAINING("%s:\n wait = %d\n",
 		__func__,
 		default_wait_in_micro_secs);
 }
@@ -79,8 +80,7 @@ static void dpcd_set_training_pattern(
 		&dpcd_pattern.raw,
 		1);
 
-	DC_LOG_HW_LINK_TRAINING(link->ctx->logger,
-		"%s\n %x pattern = %x\n",
+	DC_LOG_HW_LINK_TRAINING("%s\n %x pattern = %x\n",
 		__func__,
 		DP_TRAINING_PATTERN_SET,
 		dpcd_pattern.v1_4.TRAINING_PATTERN_SET);
@@ -116,8 +116,7 @@ static void dpcd_set_link_settings(
 	core_link_write_dpcd(link, DP_DOWNSPREAD_CTRL,
 	&downspread.raw, sizeof(downspread));
 
-	DC_LOG_HW_LINK_TRAINING(link->ctx->logger,
-		"%s\n %x rate = %x\n %x lane = %x\n %x spread = %x\n",
+	DC_LOG_HW_LINK_TRAINING("%s\n %x rate = %x\n %x lane = %x\n %x spread = %x\n",
 		__func__,
 		DP_LINK_BW_SET,
 		lt_settings->link_settings.link_rate,
@@ -151,8 +150,7 @@ static enum dpcd_training_patterns
 		break;
 	default:
 		ASSERT(0);
-		DC_LOG_HW_LINK_TRAINING(link->ctx->logger,
-			"%s: Invalid HW Training pattern: %d\n",
+		DC_LOG_HW_LINK_TRAINING("%s: Invalid HW Training pattern: %d\n",
 			__func__, pattern);
 		break;
 	}
@@ -184,8 +182,7 @@ static void dpcd_set_lt_pattern_and_lane
 	dpcd_lt_buffer[DP_TRAINING_PATTERN_SET - dpcd_base_lt_offset]
 		= dpcd_pattern.raw;
 
-	DC_LOG_HW_LINK_TRAINING(link->ctx->logger,
-		"%s\n %x pattern = %x\n",
+	DC_LOG_HW_LINK_TRAINING("%s\n %x pattern = %x\n",
 		__func__,
 		DP_TRAINING_PATTERN_SET,
 		dpcd_pattern.v1_4.TRAINING_PATTERN_SET);
@@ -219,8 +216,7 @@ static void dpcd_set_lt_pattern_and_lane
 		dpcd_lane,
 		size_in_bytes);
 
-	DC_LOG_HW_LINK_TRAINING(link->ctx->logger,
-		"%s:\n %x VS set = %x  PE set = %x max VS Reached = %x  max PE Reached = %x\n",
+	DC_LOG_HW_LINK_TRAINING("%s:\n %x VS set = %x  PE set = %x max VS Reached = %x  max PE Reached = %x\n",
 		__func__,
 		DP_TRAINING_LANE0_SET,
 		dpcd_lane[0].bits.VOLTAGE_SWING_SET,
@@ -456,14 +452,12 @@ static void get_lane_status_and_drive_se
 
 	ln_status_updated->raw = dpcd_buf[2];
 
-	DC_LOG_HW_LINK_TRAINING(link->ctx->logger,
-		"%s:\n%x Lane01Status = %x\n %x Lane23Status = %x\n ",
+	DC_LOG_HW_LINK_TRAINING("%s:\n%x Lane01Status = %x\n %x Lane23Status = %x\n ",
 		__func__,
 		DP_LANE0_1_STATUS, dpcd_buf[0],
 		DP_LANE2_3_STATUS, dpcd_buf[1]);
 
-	DC_LOG_HW_LINK_TRAINING(link->ctx->logger,
-		"%s:\n %x Lane01AdjustRequest = %x\n %x Lane23AdjustRequest = %x\n",
+	DC_LOG_HW_LINK_TRAINING("%s:\n %x Lane01AdjustRequest = %x\n %x Lane23AdjustRequest = %x\n",
 		__func__,
 		DP_ADJUST_REQUEST_LANE0_1,
 		dpcd_buf[4],
@@ -556,8 +550,7 @@ static void dpcd_set_lane_settings(
 	}
 	*/
 
-	DC_LOG_HW_LINK_TRAINING(link->ctx->logger,
-		"%s\n %x VS set = %x  PE set = %x max VS Reached = %x  max PE Reached = %x\n",
+	DC_LOG_HW_LINK_TRAINING("%s\n %x VS set = %x  PE set = %x max VS Reached = %x  max PE Reached = %x\n",
 		__func__,
 		DP_TRAINING_LANE0_SET,
 		dpcd_lane[0].bits.VOLTAGE_SWING_SET,
@@ -669,16 +662,14 @@ static bool perform_post_lt_adj_req_sequ
 		}
 
 		if (!req_drv_setting_changed) {
-			DC_LOG_WARNING(link->ctx->logger,
-				"%s: Post Link Training Adjust Request Timed out\n",
+			DC_LOG_WARNING("%s: Post Link Training Adjust Request Timed out\n",
 				__func__);
 
 			ASSERT(0);
 			return true;
 		}
 	}
-	DC_LOG_WARNING(link->ctx->logger,
-		"%s: Post Link Training Adjust Request limit reached\n",
+	DC_LOG_WARNING("%s: Post Link Training Adjust Request limit reached\n",
 		__func__);
 
 	ASSERT(0);
@@ -885,8 +876,7 @@ static enum link_training_result perform
 
 	if (retry_count >= LINK_TRAINING_MAX_CR_RETRY) {
 		ASSERT(0);
-		DC_LOG_ERROR(link->ctx->logger,
-			"%s: Link Training Error, could not get CR after %d tries. Possibly voltage swing issue",
+		DC_LOG_ERROR("%s: Link Training Error, could not get CR after %d tries. Possibly voltage swing issue",
 			__func__,
 			LINK_TRAINING_MAX_CR_RETRY);
 
@@ -1606,8 +1596,7 @@ static bool hpd_rx_irq_check_link_loss_s
 	if (sink_status_changed ||
 		!hpd_irq_dpcd_data->bytes.lane_status_updated.bits.INTERLANE_ALIGN_DONE) {
 
-		DC_LOG_HW_HPD_IRQ(link->ctx->logger,
-			"%s: Link Status changed.\n", __func__);
+		DC_LOG_HW_HPD_IRQ("%s: Link Status changed.\n", __func__);
 
 		return_code = true;
 
@@ -1620,8 +1609,7 @@ static bool hpd_rx_irq_check_link_loss_s
 			sizeof(irq_reg_rx_power_state));
 
 		if (dpcd_result != DC_OK) {
-			DC_LOG_HW_HPD_IRQ(link->ctx->logger,
-				"%s: DPCD read failed to obtain power state.\n",
+			DC_LOG_HW_HPD_IRQ("%s: DPCD read failed to obtain power state.\n",
 				__func__);
 		} else {
 			if (irq_reg_rx_power_state != DP_SET_POWER_D0)
@@ -1982,8 +1970,7 @@ bool dc_link_handle_hpd_rx_irq(struct dc
 	 * PSR and device auto test, refer to function handle_sst_hpd_irq
 	 * in DAL2.1*/
 
-	DC_LOG_HW_HPD_IRQ(link->ctx->logger,
-		"%s: Got short pulse HPD on link %d\n",
+	DC_LOG_HW_HPD_IRQ("%s: Got short pulse HPD on link %d\n",
 		__func__, link->link_index);
 
 
@@ -1997,8 +1984,7 @@ bool dc_link_handle_hpd_rx_irq(struct dc
 		*out_hpd_irq_dpcd_data = hpd_irq_dpcd_data;
 
 	if (result != DC_OK) {
-		DC_LOG_HW_HPD_IRQ(link->ctx->logger,
-			"%s: DPCD read failed to obtain irq data\n",
+		DC_LOG_HW_HPD_IRQ("%s: DPCD read failed to obtain irq data\n",
 			__func__);
 		return false;
 	}
@@ -2016,8 +2002,7 @@ bool dc_link_handle_hpd_rx_irq(struct dc
 	}
 
 	if (!allow_hpd_rx_irq(link)) {
-		DC_LOG_HW_HPD_IRQ(link->ctx->logger,
-			"%s: skipping HPD handling on %d\n",
+		DC_LOG_HW_HPD_IRQ("%s: skipping HPD handling on %d\n",
 			__func__, link->link_index);
 		return false;
 	}
--- a/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc_resource.c
@@ -45,7 +45,8 @@
 #include "dcn10/dcn10_resource.h"
 #endif
 #include "dce120/dce120_resource.h"
-
+#define DC_LOGGER \
+	ctx->logger
 enum dce_version resource_parse_asic_id(struct hw_asic_id asic_id)
 {
 	enum dce_version dc_version = DCE_VERSION_UNKNOWN;
@@ -834,7 +835,7 @@ bool resource_build_scaling_params(struc
 	struct dc_crtc_timing *timing = &pipe_ctx->stream->timing;
 	struct view recout_skip = { 0 };
 	bool res = false;
-
+	struct dc_context *ctx = pipe_ctx->stream->ctx;
 	/* Important: scaling ratio calculation requires pixel format,
 	 * lb depth calculation requires recout and taps require scaling ratios.
 	 * Inits require viewport, taps, ratios and recout of split pipe
@@ -893,7 +894,7 @@ bool resource_build_scaling_params(struc
 		/* May need to re-check lb size after this in some obscure scenario */
 		calculate_inits_and_adj_vp(pipe_ctx, &recout_skip);
 
-	DC_LOG_SCALER(pipe_ctx->stream->ctx->logger,
+	DC_LOG_SCALER(
 				"%s: Viewport:\nheight:%d width:%d x:%d "
 				"y:%d\n dst_rect:\nheight:%d width:%d x:%d "
 				"y:%d\n",
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_abm.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_abm.c
@@ -42,6 +42,8 @@
 #define FN(reg_name, field_name) \
 	abm_dce->abm_shift->field_name, abm_dce->abm_mask->field_name
 
+#define DC_LOGGER \
+	abm->ctx->logger
 #define CTX \
 	abm_dce->base.ctx
 
@@ -403,8 +405,7 @@ static bool dce_abm_set_backlight_level(
 {
 	struct dce_abm *abm_dce = TO_DCE_ABM(abm);
 
-	DC_LOG_BACKLIGHT(abm->ctx->logger,
-			"New Backlight level: %d (0x%X)\n",
+	DC_LOG_BACKLIGHT("New Backlight level: %d (0x%X)\n",
 			backlight_level, backlight_level);
 
 	/* If DMCU is in reset state, DMCU is uninitialized */
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_audio.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_audio.c
@@ -33,6 +33,8 @@
 
 #define CTX \
 	aud->base.ctx
+#define DC_LOGGER \
+	aud->base.ctx->logger
 #define REG(reg)\
 	(aud->regs->reg)
 
@@ -63,8 +65,7 @@ static void write_indirect_azalia_reg(st
 	REG_SET(AZALIA_F0_CODEC_ENDPOINT_DATA, 0,
 			AZALIA_ENDPOINT_REG_DATA, reg_data);
 
-	DC_LOG_HW_AUDIO(CTX->logger,
-		"AUDIO:write_indirect_azalia_reg: index: %u  data: %u\n",
+	DC_LOG_HW_AUDIO("AUDIO:write_indirect_azalia_reg: index: %u  data: %u\n",
 		reg_index, reg_data);
 }
 
@@ -81,8 +82,7 @@ static uint32_t read_indirect_azalia_reg
 	/* AZALIA_F0_CODEC_ENDPOINT_DATA  endpoint data  */
 	value = REG_READ(AZALIA_F0_CODEC_ENDPOINT_DATA);
 
-	DC_LOG_HW_AUDIO(CTX->logger,
-		"AUDIO:read_indirect_azalia_reg: index: %u  data: %u\n",
+	DC_LOG_HW_AUDIO("AUDIO:read_indirect_azalia_reg: index: %u  data: %u\n",
 		reg_index, value);
 
 	return value;
@@ -364,8 +364,7 @@ void dce_aud_az_enable(struct audio *aud
 			CLOCK_GATING_DISABLE);
 	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL, value);
 
-	DC_LOG_HW_AUDIO(CTX->logger,
-			"\n\t========= AUDIO:dce_aud_az_enable: index: %u  data: 0x%x\n",
+	DC_LOG_HW_AUDIO("\n\t========= AUDIO:dce_aud_az_enable: index: %u  data: 0x%x\n",
 			audio->inst, value);
 }
 
@@ -390,8 +389,7 @@ void dce_aud_az_disable(struct audio *au
 			CLOCK_GATING_DISABLE);
 	AZ_REG_WRITE(AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL, value);
 	value = AZ_REG_READ(AZALIA_F0_CODEC_PIN_CONTROL_HOT_PLUG_CONTROL);
-	DC_LOG_HW_AUDIO(CTX->logger,
-			"\n\t========= AUDIO:dce_aud_az_disable: index: %u  data: 0x%x\n",
+	DC_LOG_HW_AUDIO("\n\t========= AUDIO:dce_aud_az_disable: index: %u  data: 0x%x\n",
 			audio->inst, value);
 }
 
@@ -795,8 +793,7 @@ void dce_aud_wall_dto_setup(
 			crtc_info->calculated_pixel_clock,
 			&clock_info);
 
-		DC_LOG_HW_AUDIO(audio->ctx->logger, \
-				"\n%s:Input::requested_pixel_clock = %d"\
+		DC_LOG_HW_AUDIO("\n%s:Input::requested_pixel_clock = %d"\
 				"calculated_pixel_clock =%d\n"\
 				"audio_dto_module = %d audio_dto_phase =%d \n\n", __func__,\
 				crtc_info->requested_pixel_clock,\
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_clock_source.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_clock_source.c
@@ -41,7 +41,8 @@
 
 #define CTX \
 	clk_src->base.ctx
-
+#define DC_LOGGER \
+	calc_pll_cs->ctx->logger
 #undef FN
 #define FN(reg_name, field_name) \
 	clk_src->cs_shift->field_name, clk_src->cs_mask->field_name
@@ -288,7 +289,7 @@ static uint32_t calculate_pixel_clock_pl
 	uint32_t max_ref_divider;
 
 	if (pll_settings->adjusted_pix_clk == 0) {
-		DC_LOG_ERROR(calc_pll_cs->ctx->logger,
+		DC_LOG_ERROR(
 			"%s Bad requested pixel clock", __func__);
 		return MAX_PLL_CALC_ERROR;
 	}
@@ -349,13 +350,13 @@ static uint32_t calculate_pixel_clock_pl
  *  ## SVS Wed 15 Jul 2009 */
 
 	if (min_post_divider > max_post_divider) {
-		DC_LOG_ERROR(calc_pll_cs->ctx->logger,
+		DC_LOG_ERROR(
 			"%s Post divider range is invalid", __func__);
 		return MAX_PLL_CALC_ERROR;
 	}
 
 	if (min_ref_divider > max_ref_divider) {
-		DC_LOG_ERROR(calc_pll_cs->ctx->logger,
+		DC_LOG_ERROR(
 			"%s Reference divider range is invalid", __func__);
 		return MAX_PLL_CALC_ERROR;
 	}
@@ -466,7 +467,7 @@ static uint32_t dce110_get_pix_clk_divid
 {
 	uint32_t field = 0;
 	uint32_t pll_calc_error = MAX_PLL_CALC_ERROR;
-
+	struct calc_pll_clock_source *calc_pll_cs = &clk_src->calc_pll;
 	/* Check if reference clock is external (not pcie/xtalin)
 	* HW Dce80 spec:
 	* 00 - PCIE_REFCLK, 01 - XTALIN,    02 - GENERICA,    03 - GENERICB
@@ -493,7 +494,7 @@ static uint32_t dce110_get_pix_clk_divid
 	if (!pll_adjust_pix_clk(clk_src, pix_clk_params, pll_settings)) {
 		/* Should never happen, ASSERT and fill up values to be able
 		 * to continue. */
-		DC_LOG_ERROR(clk_src->base.ctx->logger,
+		DC_LOG_ERROR(
 			"%s: Failed to adjust pixel clock!!", __func__);
 		pll_settings->actual_pix_clk =
 				pix_clk_params->requested_pix_clk;
@@ -556,11 +557,12 @@ static uint32_t dce110_get_pix_clk_divid
 		struct pll_settings *pll_settings)
 {
 	struct dce110_clk_src *clk_src = TO_DCE110_CLK_SRC(cs);
+	struct calc_pll_clock_source *calc_pll_cs = &clk_src->calc_pll;
 	uint32_t pll_calc_error = MAX_PLL_CALC_ERROR;
 
 	if (pix_clk_params == NULL || pll_settings == NULL
 			|| pix_clk_params->requested_pix_clk == 0) {
-		DC_LOG_ERROR(clk_src->base.ctx->logger,
+		DC_LOG_ERROR(
 			"%s: Invalid parameters!!\n", __func__);
 		return pll_calc_error;
 	}
@@ -1052,14 +1054,14 @@ static void get_ss_info_from_atombios(
 	struct spread_spectrum_info *ss_info_cur;
 	struct spread_spectrum_data *ss_data_cur;
 	uint32_t i;
-
+	struct calc_pll_clock_source *calc_pll_cs = &clk_src->calc_pll;
 	if (ss_entries_num == NULL) {
-		DC_LOG_SYNC(clk_src->base.ctx->logger,
+		DC_LOG_SYNC(
 			"Invalid entry !!!\n");
 		return;
 	}
 	if (spread_spectrum_data == NULL) {
-		DC_LOG_SYNC(clk_src->base.ctx->logger,
+		DC_LOG_SYNC(
 			"Invalid array pointer!!!\n");
 		return;
 	}
@@ -1104,7 +1106,7 @@ static void get_ss_info_from_atombios(
 		++i, ++ss_info_cur, ++ss_data_cur) {
 
 		if (ss_info_cur->type.STEP_AND_DELAY_INFO != false) {
-			DC_LOG_SYNC(clk_src->base.ctx->logger,
+			DC_LOG_SYNC(
 				"Invalid ATOMBIOS SS Table!!!\n");
 			goto out_free_data;
 		}
@@ -1114,9 +1116,9 @@ static void get_ss_info_from_atombios(
 		if (as_signal == AS_SIGNAL_TYPE_HDMI
 				&& ss_info_cur->spread_spectrum_percentage > 6){
 			/* invalid input, do nothing */
-			DC_LOG_SYNC(clk_src->base.ctx->logger,
+			DC_LOG_SYNC(
 				"Invalid SS percentage ");
-			DC_LOG_SYNC(clk_src->base.ctx->logger,
+			DC_LOG_SYNC(
 				"for HDMI in ATOMBIOS info Table!!!\n");
 			continue;
 		}
@@ -1228,12 +1230,12 @@ static bool calc_pll_max_vco_construct(
 	if (init_data->num_fract_fb_divider_decimal_point == 0 ||
 		init_data->num_fract_fb_divider_decimal_point_precision >
 				init_data->num_fract_fb_divider_decimal_point) {
-		DC_LOG_ERROR(calc_pll_cs->ctx->logger,
+		DC_LOG_ERROR(
 			"The dec point num or precision is incorrect!");
 		return false;
 	}
 	if (init_data->num_fract_fb_divider_decimal_point_precision == 0) {
-		DC_LOG_ERROR(calc_pll_cs->ctx->logger,
+		DC_LOG_ERROR(
 			"Incorrect fract feedback divider precision num!");
 		return false;
 	}
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_clocks.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_clocks.c
@@ -49,6 +49,8 @@
 
 #define CTX \
 	clk_dce->base.ctx
+#define DC_LOGGER \
+	clk->ctx->logger
 
 /* Max clock values for each state indexed by "enum clocks_state": */
 static const struct state_dependent_clocks dce80_max_clks_by_state[] = {
@@ -292,8 +294,7 @@ static enum dm_pp_clocks_state dce_get_r
 
 	low_req_clk = i + 1;
 	if (low_req_clk > clk->max_clks_state) {
-		DC_LOG_WARNING(clk->ctx->logger,
-				"%s: clocks unsupported disp_clk %d pix_clk %d",
+		DC_LOG_WARNING("%s: clocks unsupported disp_clk %d pix_clk %d",
 				__func__,
 				req_clocks->display_clk_khz,
 				req_clocks->pixel_clk_khz);
@@ -312,8 +313,7 @@ static bool dce_clock_set_min_clocks_sta
 
 	if (clocks_state > clk->max_clks_state) {
 		/*Requested state exceeds max supported state.*/
-		DC_LOG_WARNING(clk->ctx->logger,
-				"Requested state exceeds max supported state");
+		DC_LOG_WARNING("Requested state exceeds max supported state");
 		return false;
 	} else if (clocks_state == clk->cur_min_clks_state) {
 		/*if we're trying to set the same state, we can just return
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_link_encoder.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_link_encoder.c
@@ -56,6 +56,8 @@
 
 #define CTX \
 	enc110->base.ctx
+#define DC_LOGGER \
+	enc110->base.ctx->logger
 
 #define REG(reg)\
 	(enc110->link_regs->reg)
@@ -819,7 +821,6 @@ void dce110_link_encoder_hw_init(
 	struct link_encoder *enc)
 {
 	struct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);
-	struct dc_context *ctx = enc110->base.ctx;
 	struct bp_transmitter_control cntl = { 0 };
 	enum bp_result result;
 
@@ -837,8 +838,7 @@ void dce110_link_encoder_hw_init(
 	result = link_transmitter_control(enc110, &cntl);
 
 	if (result != BP_RESULT_OK) {
-		DC_LOG_ERROR(ctx->logger,
-			"%s: Failed to execute VBIOS command table!\n",
+		DC_LOG_ERROR("%s: Failed to execute VBIOS command table!\n",
 			__func__);
 		BREAK_TO_DEBUGGER();
 		return;
@@ -914,7 +914,6 @@ void dce110_link_encoder_enable_tmds_out
 	uint32_t pixel_clock)
 {
 	struct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);
-	struct dc_context *ctx = enc110->base.ctx;
 	struct bp_transmitter_control cntl = { 0 };
 	enum bp_result result;
 
@@ -938,8 +937,7 @@ void dce110_link_encoder_enable_tmds_out
 	result = link_transmitter_control(enc110, &cntl);
 
 	if (result != BP_RESULT_OK) {
-		DC_LOG_ERROR(ctx->logger,
-			"%s: Failed to execute VBIOS command table!\n",
+		DC_LOG_ERROR("%s: Failed to execute VBIOS command table!\n",
 			__func__);
 		BREAK_TO_DEBUGGER();
 	}
@@ -952,7 +950,6 @@ void dce110_link_encoder_enable_dp_outpu
 	enum clock_source_id clock_source)
 {
 	struct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);
-	struct dc_context *ctx = enc110->base.ctx;
 	struct bp_transmitter_control cntl = { 0 };
 	enum bp_result result;
 
@@ -979,8 +976,7 @@ void dce110_link_encoder_enable_dp_outpu
 	result = link_transmitter_control(enc110, &cntl);
 
 	if (result != BP_RESULT_OK) {
-		DC_LOG_ERROR(ctx->logger,
-			"%s: Failed to execute VBIOS command table!\n",
+		DC_LOG_ERROR("%s: Failed to execute VBIOS command table!\n",
 			__func__);
 		BREAK_TO_DEBUGGER();
 	}
@@ -993,7 +989,6 @@ void dce110_link_encoder_enable_dp_mst_o
 	enum clock_source_id clock_source)
 {
 	struct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);
-	struct dc_context *ctx = enc110->base.ctx;
 	struct bp_transmitter_control cntl = { 0 };
 	enum bp_result result;
 
@@ -1020,8 +1015,7 @@ void dce110_link_encoder_enable_dp_mst_o
 	result = link_transmitter_control(enc110, &cntl);
 
 	if (result != BP_RESULT_OK) {
-		DC_LOG_ERROR(ctx->logger,
-			"%s: Failed to execute VBIOS command table!\n",
+		DC_LOG_ERROR("%s: Failed to execute VBIOS command table!\n",
 			__func__);
 		BREAK_TO_DEBUGGER();
 	}
@@ -1035,7 +1029,6 @@ void dce110_link_encoder_disable_output(
 	enum signal_type signal)
 {
 	struct dce110_link_encoder *enc110 = TO_DCE110_LINK_ENC(enc);
-	struct dc_context *ctx = enc110->base.ctx;
 	struct bp_transmitter_control cntl = { 0 };
 	enum bp_result result;
 
@@ -1063,8 +1056,7 @@ void dce110_link_encoder_disable_output(
 	result = link_transmitter_control(enc110, &cntl);
 
 	if (result != BP_RESULT_OK) {
-		DC_LOG_ERROR(ctx->logger,
-			"%s: Failed to execute VBIOS command table!\n",
+		DC_LOG_ERROR("%s: Failed to execute VBIOS command table!\n",
 			__func__);
 		BREAK_TO_DEBUGGER();
 		return;
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_stream_encoder.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_stream_encoder.c
@@ -26,7 +26,8 @@
 #include "dc_bios_types.h"
 #include "dce_stream_encoder.h"
 #include "reg_helper.h"
-
+#define DC_LOGGER \
+		enc110->base.ctx->logger
 enum DP_PIXEL_ENCODING {
 DP_PIXEL_ENCODING_RGB444                 = 0x00000000,
 DP_PIXEL_ENCODING_YCBCR422               = 0x00000001,
@@ -197,7 +198,6 @@ static void dce110_update_hdmi_info_pack
 	uint32_t packet_index,
 	const struct encoder_info_packet *info_packet)
 {
-	struct dc_context *ctx = enc110->base.ctx;
 	uint32_t cont, send, line;
 
 	if (info_packet->valid) {
@@ -278,7 +278,6 @@ static void dce110_update_hdmi_info_pack
 	default:
 		/* invalid HW packet index */
 		DC_LOG_WARNING(
-			ctx->logger,
 			"Invalid HW packet index: %s()\n",
 			__func__);
 		return;
@@ -1386,7 +1385,7 @@ static void dce110_se_setup_hdmi_audio(
 			     crtc_info->requested_pixel_clock,
 			     crtc_info->calculated_pixel_clock,
 			     &audio_clock_info);
-	DC_LOG_HW_AUDIO(enc->ctx->logger,
+	DC_LOG_HW_AUDIO(
 			"\n%s:Input::requested_pixel_clock = %d"	\
 			"calculated_pixel_clock = %d \n", __func__,	\
 			crtc_info->requested_pixel_clock,		\
--- a/drivers/gpu/drm/amd/display/dc/dce/dce_transform.c
+++ b/drivers/gpu/drm/amd/display/dc/dce/dce_transform.c
@@ -38,6 +38,8 @@
 
 #define CTX \
 	xfm_dce->base.ctx
+#define DC_LOGGER \
+	xfm_dce->base.ctx->logger
 
 #define IDENTITY_RATIO(ratio) (dal_fixed31_32_u2d19(ratio) == (1 << 19))
 #define GAMUT_MATRIX_SIZE 12
@@ -693,8 +695,7 @@ static int dce_transform_get_max_num_of_
 		break;
 
 	default:
-		DC_LOG_WARNING(xfm_dce->base.ctx->logger,
-			"%s: Invalid LB pixel depth",
+		DC_LOG_WARNING("%s: Invalid LB pixel depth",
 			__func__);
 		BREAK_TO_DEBUGGER();
 		break;
@@ -791,8 +792,7 @@ static void dce_transform_set_pixel_stor
 	if (!(xfm_dce->lb_pixel_depth_supported & depth)) {
 		/*we should use unsupported capabilities
 		 *  unless it is required by w/a*/
-		DC_LOG_WARNING(xfm->ctx->logger,
-			"%s: Capability not supported",
+		DC_LOG_WARNING("%s: Capability not supported",
 			__func__);
 	}
 }
@@ -1172,8 +1172,7 @@ static void program_pwl(struct dce_trans
 	}
 
 	if (counter == max_tries) {
-		DC_LOG_WARNING(xfm_dce->base.ctx->logger,
-				"%s: regamma lut was not powered on "
+		DC_LOG_WARNING("%s: regamma lut was not powered on "
 				"in a timely manner,"
 				" programming still proceeds\n",
 				__func__);
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_compressor.c
@@ -34,6 +34,8 @@
 
 #include "dce110_compressor.h"
 
+#define DC_LOGGER \
+		cp110->base.ctx->logger
 #define DCP_REG(reg)\
 	(reg + cp110->offsets.dcp_offset)
 #define DMIF_REG(reg)\
@@ -120,14 +122,10 @@ static void wait_for_fbc_state_changed(
 	}
 
 	if (counter == 10) {
-		DC_LOG_WARNING(
-			cp110->base.ctx->logger,
-			"%s: wait counter exceeded, changes to HW not applied",
+		DC_LOG_WARNING("%s: wait counter exceeded, changes to HW not applied",
 			__func__);
 	} else {
-		DC_LOG_SYNC(
-			cp110->base.ctx->logger,
-			"FBC status changed to %d", enabled);
+		DC_LOG_SYNC("FBC status changed to %d", enabled);
 	}
 
 
@@ -310,9 +308,7 @@ void dce110_compressor_program_compresse
 	if (compressor->min_compress_ratio == FBC_COMPRESS_RATIO_1TO1)
 		fbc_pitch = fbc_pitch / 8;
 	else
-		DC_LOG_WARNING(
-			compressor->ctx->logger,
-			"%s: Unexpected DCE11 compression ratio",
+		DC_LOG_WARNING("%s: Unexpected DCE11 compression ratio",
 			__func__);
 
 	/* Clear content first. */
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
@@ -70,6 +70,8 @@
 
 #define CTX \
 	hws->ctx
+#define DC_LOGGER \
+	ctx->logger
 #define REG(reg)\
 	hws->regs->reg
 
@@ -819,7 +821,7 @@ void hwss_edp_wait_for_hpd_ready(
 	dal_gpio_destroy_irq(&hpd);
 
 	if (false == edp_hpd_high) {
-		DC_LOG_ERROR(ctx->logger,
+		DC_LOG_ERROR(
 				"%s: wait timed out!\n", __func__);
 	}
 }
@@ -843,7 +845,7 @@ void hwss_edp_power_control(
 	if (power_up != is_panel_powered_on(hwseq)) {
 		/* Send VBIOS command to prompt eDP panel power */
 
-		DC_LOG_HW_RESUME_S3(ctx->logger,
+		DC_LOG_HW_RESUME_S3(
 				"%s: Panel Power action: %s\n",
 				__func__, (power_up ? "On":"Off"));
 
@@ -859,11 +861,11 @@ void hwss_edp_power_control(
 		bp_result = link_transmitter_control(ctx->dc_bios, &cntl);
 
 		if (bp_result != BP_RESULT_OK)
-			DC_LOG_ERROR(ctx->logger,
+			DC_LOG_ERROR(
 					"%s: Panel Power bp_result: %d\n",
 					__func__, bp_result);
 	} else {
-		DC_LOG_HW_RESUME_S3(ctx->logger,
+		DC_LOG_HW_RESUME_S3(
 				"%s: Skipping Panel Power action: %s\n",
 				__func__, (power_up ? "On":"Off"));
 	}
@@ -889,7 +891,7 @@ void hwss_edp_backlight_control(
 	}
 
 	if (enable && is_panel_backlight_on(hws)) {
-		DC_LOG_HW_RESUME_S3(ctx->logger,
+		DC_LOG_HW_RESUME_S3(
 				"%s: panel already powered up. Do nothing.\n",
 				__func__);
 		return;
@@ -897,7 +899,7 @@ void hwss_edp_backlight_control(
 
 	/* Send VBIOS command to control eDP panel backlight */
 
-	DC_LOG_HW_RESUME_S3(ctx->logger,
+	DC_LOG_HW_RESUME_S3(
 			"%s: backlight action: %s\n",
 			__func__, (enable ? "On":"Off"));
 
@@ -2690,7 +2692,7 @@ static void dce110_program_front_end_for
 	struct xfm_grph_csc_adjustment adjust;
 	struct out_csc_color_matrix tbl_entry;
 	unsigned int i;
-
+	struct dc_context *ctx = dc->ctx;
 	memset(&tbl_entry, 0, sizeof(tbl_entry));
 
 	if (dc->current_state)
@@ -2765,7 +2767,7 @@ static void dce110_program_front_end_for
 	if (pipe_ctx->plane_state->update_flags.bits.full_update)
 		dc->hwss.set_output_transfer_func(pipe_ctx, pipe_ctx->stream);
 
-	DC_LOG_SURFACE(dc->ctx->logger,
+	DC_LOG_SURFACE(
 			"Pipe:%d 0x%x: addr hi:0x%x, "
 			"addr low:0x%x, "
 			"src: %d, %d, %d,"
@@ -2788,7 +2790,7 @@ static void dce110_program_front_end_for
 			pipe_ctx->plane_state->clip_rect.width,
 			pipe_ctx->plane_state->clip_rect.height);
 
-	DC_LOG_SURFACE(dc->ctx->logger,
+	DC_LOG_SURFACE(
 			"Pipe %d: width, height, x, y\n"
 			"viewport:%d, %d, %d, %d\n"
 			"recout:  %d, %d, %d, %d\n",
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c
@@ -52,6 +52,8 @@
 #include "dce/dce_abm.h"
 #include "dce/dce_dmcu.h"
 
+#define DC_LOGGER \
+		dc->ctx->logger
 #if defined(CONFIG_DRM_AMD_DC_FBC)
 #include "dce110/dce110_compressor.h"
 #endif
@@ -772,7 +774,6 @@ static bool dce110_validate_bandwidth(
 	bool result = false;
 
 	DC_LOG_BANDWIDTH_CALCS(
-		dc->ctx->logger,
 		"%s: start",
 		__func__);
 
@@ -786,8 +787,7 @@ static bool dce110_validate_bandwidth(
 		result =  true;
 
 	if (!result)
-		DC_LOG_BANDWIDTH_VALIDATION(dc->ctx->logger,
-			"%s: %dx%d@%d Bandwidth validation failed!\n",
+		DC_LOG_BANDWIDTH_VALIDATION("%s: %dx%d@%d Bandwidth validation failed!\n",
 			__func__,
 			context->streams[0]->timing.h_addressable,
 			context->streams[0]->timing.v_addressable,
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_timing_generator_v.c
@@ -15,6 +15,8 @@
 
 #include "timing_generator.h"
 
+#define DC_LOGGER \
+	tg->ctx->logger
 /** ********************************************************************************
  *
  * DCE11 Timing Generator Implementation
@@ -583,8 +585,7 @@ static uint32_t dce110_timing_generator_
 static bool dce110_timing_generator_v_did_triggered_reset_occur(
 	struct timing_generator *tg)
 {
-	DC_LOG_ERROR(tg->ctx->logger,
-					"Timing Sync not supported on underlay pipe\n");
+	DC_LOG_ERROR("Timing Sync not supported on underlay pipe\n");
 	return false;
 }
 
@@ -592,8 +593,7 @@ static void dce110_timing_generator_v_se
 	struct timing_generator *tg,
 	const struct dcp_gsl_params *gsl_params)
 {
-	DC_LOG_ERROR(tg->ctx->logger,
-					"Timing Sync not supported on underlay pipe\n");
+	DC_LOG_ERROR("Timing Sync not supported on underlay pipe\n");
 	return;
 }
 
@@ -601,24 +601,21 @@ static void dce110_timing_generator_v_en
 	struct timing_generator *tg,
 	int source_tg_inst)
 {
-	DC_LOG_ERROR(tg->ctx->logger,
-					"Timing Sync not supported on underlay pipe\n");
+	DC_LOG_ERROR("Timing Sync not supported on underlay pipe\n");
 	return;
 }
 
 static void dce110_timing_generator_v_disable_reset_trigger(
 	struct timing_generator *tg)
 {
-	DC_LOG_ERROR(tg->ctx->logger,
-						"Timing Sync not supported on underlay pipe\n");
+	DC_LOG_ERROR("Timing Sync not supported on underlay pipe\n");
 	return;
 }
 
 static void dce110_timing_generator_v_tear_down_global_swap_lock(
 	struct timing_generator *tg)
 {
-	DC_LOG_ERROR(tg->ctx->logger,
-						"Timing Sync not supported on underlay pipe\n");
+	DC_LOG_ERROR("Timing Sync not supported on underlay pipe\n");
 	return;
 }
 
--- a/drivers/gpu/drm/amd/display/dc/dce110/dce110_transform_v.c
+++ b/drivers/gpu/drm/amd/display/dc/dce110/dce110_transform_v.c
@@ -30,6 +30,8 @@
 #include "dce/dce_11_0_sh_mask.h"
 
 #define SCLV_PHASES 64
+#define DC_LOGGER \
+	xfm->ctx->logger
 
 struct sclv_ratios_inits {
 	uint32_t h_int_scale_ratio_luma;
@@ -670,8 +672,7 @@ static void dce110_xfmv_set_pixel_storag
 	if (!(xfm_dce->lb_pixel_depth_supported & depth)) {
 		/*we should use unsupported capabilities
 		 *  unless it is required by w/a*/
-		DC_LOG_WARNING(xfm->ctx->logger,
-			"%s: Capability not supported",
+		DC_LOG_WARNING("%s: Capability not supported",
 			__func__);
 	}
 }
--- a/drivers/gpu/drm/amd/display/dc/dce112/dce112_compressor.c
+++ b/drivers/gpu/drm/amd/display/dc/dce112/dce112_compressor.c
@@ -33,7 +33,8 @@
 #include "include/logger_interface.h"
 
 #include "dce112_compressor.h"
-
+#define DC_LOGGER \
+		cp110->base.ctx->logger
 #define DCP_REG(reg)\
 	(reg + cp110->offsets.dcp_offset)
 #define DMIF_REG(reg)\
@@ -130,7 +131,6 @@ static uint32_t lpt_memory_control_confi
 			break;
 		default:
 			DC_LOG_WARNING(
-				cp110->base.ctx->logger,
 				"%s: Invalid LPT NUM_PIPES!!!",
 				__func__);
 			break;
@@ -176,7 +176,6 @@ static uint32_t lpt_memory_control_confi
 			break;
 		default:
 			DC_LOG_WARNING(
-				cp110->base.ctx->logger,
 				"%s: Invalid LPT NUM_BANKS!!!",
 				__func__);
 			break;
@@ -210,7 +209,6 @@ static uint32_t lpt_memory_control_confi
 			break;
 		default:
 			DC_LOG_WARNING(
-				cp110->base.ctx->logger,
 				"%s: Invalid LPT INTERLEAVE_SIZE!!!",
 				__func__);
 			break;
@@ -254,14 +252,12 @@ static uint32_t lpt_memory_control_confi
 			break;
 		default:
 			DC_LOG_WARNING(
-				cp110->base.ctx->logger,
 				"%s: Invalid LPT ROW_SIZE!!!",
 				__func__);
 			break;
 		}
 	} else {
 		DC_LOG_WARNING(
-			cp110->base.ctx->logger,
 			"%s: LPT MC Configuration is not provided",
 			__func__);
 	}
@@ -312,7 +308,6 @@ static void wait_for_fbc_state_changed(
 
 	if (counter == 10) {
 		DC_LOG_WARNING(
-			cp110->base.ctx->logger,
 			"%s: wait counter exceeded, changes to HW not applied",
 			__func__);
 	}
@@ -526,7 +521,6 @@ void dce112_compressor_program_compresse
 		fbc_pitch = fbc_pitch / 8;
 	else
 		DC_LOG_WARNING(
-			compressor->ctx->logger,
 			"%s: Unexpected DCE11 compression ratio",
 			__func__);
 
@@ -691,7 +685,6 @@ void dce112_compressor_program_lpt_contr
 		break;
 	default:
 		DC_LOG_WARNING(
-			compressor->ctx->logger,
 			"%s: Invalid selected DRAM channels for LPT!!!",
 			__func__);
 		break;
--- a/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c
+++ b/drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c
@@ -56,6 +56,8 @@
 #include "dce/dce_11_2_sh_mask.h"
 
 #include "dce100/dce100_resource.h"
+#define DC_LOGGER \
+		dc->ctx->logger
 
 #ifndef mmDP_DPHY_INTERNAL_CTRL
 	#define mmDP_DPHY_INTERNAL_CTRL 0x4aa7
@@ -723,7 +725,6 @@ bool dce112_validate_bandwidth(
 	bool result = false;
 
 	DC_LOG_BANDWIDTH_CALCS(
-		dc->ctx->logger,
 		"%s: start",
 		__func__);
 
@@ -737,7 +738,7 @@ bool dce112_validate_bandwidth(
 		result = true;
 
 	if (!result)
-		DC_LOG_BANDWIDTH_VALIDATION(dc->ctx->logger,
+		DC_LOG_BANDWIDTH_VALIDATION(
 			"%s: Bandwidth validation failed!",
 			__func__);
 
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hubbub.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hubbub.c
@@ -30,6 +30,8 @@
 
 #define CTX \
 	hubbub->ctx
+#define DC_LOGGER \
+	hubbub->ctx->logger
 #define REG(reg)\
 	hubbub->regs->reg
 
@@ -147,8 +149,7 @@ bool hubbub1_verify_allow_pstate_change_
 		if (debug_data & (1 << 30)) {
 
 			if (i > pstate_wait_expected_timeout_us)
-				DC_LOG_WARNING(hubbub->ctx->logger,
-						"pstate took longer than expected ~%dus\n",
+				DC_LOG_WARNING("pstate took longer than expected ~%dus\n",
 						i);
 
 			return true;
@@ -167,8 +168,7 @@ bool hubbub1_verify_allow_pstate_change_
 		     DCHUBBUB_ARB_ALLOW_PSTATE_CHANGE_FORCE_ENABLE, 1);
 	forced_pstate_allow = true;
 
-	DC_LOG_WARNING(hubbub->ctx->logger,
-			"pstate TEST_DEBUG_DATA: 0x%X\n",
+	DC_LOG_WARNING("pstate TEST_DEBUG_DATA: 0x%X\n",
 			debug_data);
 
 	return false;
@@ -211,16 +211,14 @@ void hubbub1_program_watermarks(
 			refclk_mhz, 0x1fffff);
 	REG_WRITE(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_A, prog_wm_value);
 
-	DC_LOG_BANDWIDTH_CALCS(hubbub->ctx->logger,
-		"URGENCY_WATERMARK_A calculated =%d\n"
+	DC_LOG_BANDWIDTH_CALCS("URGENCY_WATERMARK_A calculated =%d\n"
 		"HW register value = 0x%x\n",
 		watermarks->a.urgent_ns, prog_wm_value);
 
 	prog_wm_value = convert_and_clamp(watermarks->a.pte_meta_urgent_ns,
 			refclk_mhz, 0x1fffff);
 	REG_WRITE(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_A, prog_wm_value);
-	DC_LOG_BANDWIDTH_CALCS(hubbub->ctx->logger,
-		"PTE_META_URGENCY_WATERMARK_A calculated =%d\n"
+	DC_LOG_BANDWIDTH_CALCS("PTE_META_URGENCY_WATERMARK_A calculated =%d\n"
 		"HW register value = 0x%x\n",
 		watermarks->a.pte_meta_urgent_ns, prog_wm_value);
 
@@ -229,8 +227,7 @@ void hubbub1_program_watermarks(
 				watermarks->a.cstate_pstate.cstate_enter_plus_exit_ns,
 				refclk_mhz, 0x1fffff);
 		REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_A, prog_wm_value);
-		DC_LOG_BANDWIDTH_CALCS(hubbub->ctx->logger,
-			"SR_ENTER_EXIT_WATERMARK_A calculated =%d\n"
+		DC_LOG_BANDWIDTH_CALCS("SR_ENTER_EXIT_WATERMARK_A calculated =%d\n"
 			"HW register value = 0x%x\n",
 			watermarks->a.cstate_pstate.cstate_enter_plus_exit_ns, prog_wm_value);
 
@@ -239,8 +236,7 @@ void hubbub1_program_watermarks(
 				watermarks->a.cstate_pstate.cstate_exit_ns,
 				refclk_mhz, 0x1fffff);
 		REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_A, prog_wm_value);
-		DC_LOG_BANDWIDTH_CALCS(hubbub->ctx->logger,
-			"SR_EXIT_WATERMARK_A calculated =%d\n"
+		DC_LOG_BANDWIDTH_CALCS("SR_EXIT_WATERMARK_A calculated =%d\n"
 			"HW register value = 0x%x\n",
 			watermarks->a.cstate_pstate.cstate_exit_ns, prog_wm_value);
 	}
@@ -249,8 +245,7 @@ void hubbub1_program_watermarks(
 			watermarks->a.cstate_pstate.pstate_change_ns,
 			refclk_mhz, 0x1fffff);
 	REG_WRITE(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_A, prog_wm_value);
-	DC_LOG_BANDWIDTH_CALCS(hubbub->ctx->logger,
-		"DRAM_CLK_CHANGE_WATERMARK_A calculated =%d\n"
+	DC_LOG_BANDWIDTH_CALCS("DRAM_CLK_CHANGE_WATERMARK_A calculated =%d\n"
 		"HW register value = 0x%x\n\n",
 		watermarks->a.cstate_pstate.pstate_change_ns, prog_wm_value);
 
@@ -259,8 +254,7 @@ void hubbub1_program_watermarks(
 	prog_wm_value = convert_and_clamp(
 			watermarks->b.urgent_ns, refclk_mhz, 0x1fffff);
 	REG_WRITE(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_B, prog_wm_value);
-	DC_LOG_BANDWIDTH_CALCS(hubbub->ctx->logger,
-		"URGENCY_WATERMARK_B calculated =%d\n"
+	DC_LOG_BANDWIDTH_CALCS("URGENCY_WATERMARK_B calculated =%d\n"
 		"HW register value = 0x%x\n",
 		watermarks->b.urgent_ns, prog_wm_value);
 
@@ -269,8 +263,7 @@ void hubbub1_program_watermarks(
 			watermarks->b.pte_meta_urgent_ns,
 			refclk_mhz, 0x1fffff);
 	REG_WRITE(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_B, prog_wm_value);
-	DC_LOG_BANDWIDTH_CALCS(hubbub->ctx->logger,
-		"PTE_META_URGENCY_WATERMARK_B calculated =%d\n"
+	DC_LOG_BANDWIDTH_CALCS("PTE_META_URGENCY_WATERMARK_B calculated =%d\n"
 		"HW register value = 0x%x\n",
 		watermarks->b.pte_meta_urgent_ns, prog_wm_value);
 
@@ -280,8 +273,7 @@ void hubbub1_program_watermarks(
 				watermarks->b.cstate_pstate.cstate_enter_plus_exit_ns,
 				refclk_mhz, 0x1fffff);
 		REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_B, prog_wm_value);
-		DC_LOG_BANDWIDTH_CALCS(hubbub->ctx->logger,
-			"SR_ENTER_WATERMARK_B calculated =%d\n"
+		DC_LOG_BANDWIDTH_CALCS("SR_ENTER_WATERMARK_B calculated =%d\n"
 			"HW register value = 0x%x\n",
 			watermarks->b.cstate_pstate.cstate_enter_plus_exit_ns, prog_wm_value);
 
@@ -290,8 +282,7 @@ void hubbub1_program_watermarks(
 				watermarks->b.cstate_pstate.cstate_exit_ns,
 				refclk_mhz, 0x1fffff);
 		REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_B, prog_wm_value);
-		DC_LOG_BANDWIDTH_CALCS(hubbub->ctx->logger,
-			"SR_EXIT_WATERMARK_B calculated =%d\n"
+		DC_LOG_BANDWIDTH_CALCS("SR_EXIT_WATERMARK_B calculated =%d\n"
 			"HW register value = 0x%x\n",
 			watermarks->b.cstate_pstate.cstate_exit_ns, prog_wm_value);
 	}
@@ -300,8 +291,7 @@ void hubbub1_program_watermarks(
 			watermarks->b.cstate_pstate.pstate_change_ns,
 			refclk_mhz, 0x1fffff);
 	REG_WRITE(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_B, prog_wm_value);
-	DC_LOG_BANDWIDTH_CALCS(hubbub->ctx->logger,
-		"DRAM_CLK_CHANGE_WATERMARK_B calculated =%d\n\n"
+	DC_LOG_BANDWIDTH_CALCS("DRAM_CLK_CHANGE_WATERMARK_B calculated =%d\n\n"
 		"HW register value = 0x%x\n",
 		watermarks->b.cstate_pstate.pstate_change_ns, prog_wm_value);
 
@@ -309,8 +299,7 @@ void hubbub1_program_watermarks(
 	prog_wm_value = convert_and_clamp(
 			watermarks->c.urgent_ns, refclk_mhz, 0x1fffff);
 	REG_WRITE(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_C, prog_wm_value);
-	DC_LOG_BANDWIDTH_CALCS(hubbub->ctx->logger,
-		"URGENCY_WATERMARK_C calculated =%d\n"
+	DC_LOG_BANDWIDTH_CALCS("URGENCY_WATERMARK_C calculated =%d\n"
 		"HW register value = 0x%x\n",
 		watermarks->c.urgent_ns, prog_wm_value);
 
@@ -319,8 +308,7 @@ void hubbub1_program_watermarks(
 			watermarks->c.pte_meta_urgent_ns,
 			refclk_mhz, 0x1fffff);
 	REG_WRITE(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_C, prog_wm_value);
-	DC_LOG_BANDWIDTH_CALCS(hubbub->ctx->logger,
-		"PTE_META_URGENCY_WATERMARK_C calculated =%d\n"
+	DC_LOG_BANDWIDTH_CALCS("PTE_META_URGENCY_WATERMARK_C calculated =%d\n"
 		"HW register value = 0x%x\n",
 		watermarks->c.pte_meta_urgent_ns, prog_wm_value);
 
@@ -330,8 +318,7 @@ void hubbub1_program_watermarks(
 				watermarks->c.cstate_pstate.cstate_enter_plus_exit_ns,
 				refclk_mhz, 0x1fffff);
 		REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_C, prog_wm_value);
-		DC_LOG_BANDWIDTH_CALCS(hubbub->ctx->logger,
-			"SR_ENTER_WATERMARK_C calculated =%d\n"
+		DC_LOG_BANDWIDTH_CALCS("SR_ENTER_WATERMARK_C calculated =%d\n"
 			"HW register value = 0x%x\n",
 			watermarks->c.cstate_pstate.cstate_enter_plus_exit_ns, prog_wm_value);
 
@@ -340,8 +327,7 @@ void hubbub1_program_watermarks(
 				watermarks->c.cstate_pstate.cstate_exit_ns,
 				refclk_mhz, 0x1fffff);
 		REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_C, prog_wm_value);
-		DC_LOG_BANDWIDTH_CALCS(hubbub->ctx->logger,
-			"SR_EXIT_WATERMARK_C calculated =%d\n"
+		DC_LOG_BANDWIDTH_CALCS("SR_EXIT_WATERMARK_C calculated =%d\n"
 			"HW register value = 0x%x\n",
 			watermarks->c.cstate_pstate.cstate_exit_ns, prog_wm_value);
 	}
@@ -350,8 +336,7 @@ void hubbub1_program_watermarks(
 			watermarks->c.cstate_pstate.pstate_change_ns,
 			refclk_mhz, 0x1fffff);
 	REG_WRITE(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_C, prog_wm_value);
-	DC_LOG_BANDWIDTH_CALCS(hubbub->ctx->logger,
-		"DRAM_CLK_CHANGE_WATERMARK_C calculated =%d\n\n"
+	DC_LOG_BANDWIDTH_CALCS("DRAM_CLK_CHANGE_WATERMARK_C calculated =%d\n\n"
 		"HW register value = 0x%x\n",
 		watermarks->c.cstate_pstate.pstate_change_ns, prog_wm_value);
 
@@ -359,8 +344,7 @@ void hubbub1_program_watermarks(
 	prog_wm_value = convert_and_clamp(
 			watermarks->d.urgent_ns, refclk_mhz, 0x1fffff);
 	REG_WRITE(DCHUBBUB_ARB_DATA_URGENCY_WATERMARK_D, prog_wm_value);
-	DC_LOG_BANDWIDTH_CALCS(hubbub->ctx->logger,
-		"URGENCY_WATERMARK_D calculated =%d\n"
+	DC_LOG_BANDWIDTH_CALCS("URGENCY_WATERMARK_D calculated =%d\n"
 		"HW register value = 0x%x\n",
 		watermarks->d.urgent_ns, prog_wm_value);
 
@@ -368,8 +352,7 @@ void hubbub1_program_watermarks(
 			watermarks->d.pte_meta_urgent_ns,
 			refclk_mhz, 0x1fffff);
 	REG_WRITE(DCHUBBUB_ARB_PTE_META_URGENCY_WATERMARK_D, prog_wm_value);
-	DC_LOG_BANDWIDTH_CALCS(hubbub->ctx->logger,
-		"PTE_META_URGENCY_WATERMARK_D calculated =%d\n"
+	DC_LOG_BANDWIDTH_CALCS("PTE_META_URGENCY_WATERMARK_D calculated =%d\n"
 		"HW register value = 0x%x\n",
 		watermarks->d.pte_meta_urgent_ns, prog_wm_value);
 
@@ -379,8 +362,7 @@ void hubbub1_program_watermarks(
 				watermarks->d.cstate_pstate.cstate_enter_plus_exit_ns,
 				refclk_mhz, 0x1fffff);
 		REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_ENTER_WATERMARK_D, prog_wm_value);
-		DC_LOG_BANDWIDTH_CALCS(hubbub->ctx->logger,
-			"SR_ENTER_WATERMARK_D calculated =%d\n"
+		DC_LOG_BANDWIDTH_CALCS("SR_ENTER_WATERMARK_D calculated =%d\n"
 			"HW register value = 0x%x\n",
 			watermarks->d.cstate_pstate.cstate_enter_plus_exit_ns, prog_wm_value);
 
@@ -389,8 +371,7 @@ void hubbub1_program_watermarks(
 				watermarks->d.cstate_pstate.cstate_exit_ns,
 				refclk_mhz, 0x1fffff);
 		REG_WRITE(DCHUBBUB_ARB_ALLOW_SR_EXIT_WATERMARK_D, prog_wm_value);
-		DC_LOG_BANDWIDTH_CALCS(hubbub->ctx->logger,
-			"SR_EXIT_WATERMARK_D calculated =%d\n"
+		DC_LOG_BANDWIDTH_CALCS("SR_EXIT_WATERMARK_D calculated =%d\n"
 			"HW register value = 0x%x\n",
 			watermarks->d.cstate_pstate.cstate_exit_ns, prog_wm_value);
 	}
@@ -400,8 +381,7 @@ void hubbub1_program_watermarks(
 			watermarks->d.cstate_pstate.pstate_change_ns,
 			refclk_mhz, 0x1fffff);
 	REG_WRITE(DCHUBBUB_ARB_ALLOW_DRAM_CLK_CHANGE_WATERMARK_D, prog_wm_value);
-	DC_LOG_BANDWIDTH_CALCS(hubbub->ctx->logger,
-		"DRAM_CLK_CHANGE_WATERMARK_D calculated =%d\n"
+	DC_LOG_BANDWIDTH_CALCS("DRAM_CLK_CHANGE_WATERMARK_D calculated =%d\n"
 		"HW register value = 0x%x\n\n",
 		watermarks->d.cstate_pstate.pstate_change_ns, prog_wm_value);
 
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -45,6 +45,8 @@
 #include "dcn10_hubbub.h"
 #include "dcn10_cm_common.h"
 
+#define DC_LOGGER \
+	ctx->logger
 #define CTX \
 	hws->ctx
 #define REG(reg)\
@@ -352,6 +354,7 @@ static void power_on_plane(
 	struct dce_hwseq *hws,
 	int plane_id)
 {
+	struct dc_context *ctx = hws->ctx;
 	if (REG(DC_IP_REQUEST_CNTL)) {
 		REG_SET(DC_IP_REQUEST_CNTL, 0,
 				IP_REQUEST_EN, 1);
@@ -359,7 +362,7 @@ static void power_on_plane(
 		hubp_pg_control(hws, plane_id, true);
 		REG_SET(DC_IP_REQUEST_CNTL, 0,
 				IP_REQUEST_EN, 0);
-		DC_LOG_DEBUG(hws->ctx->logger,
+		DC_LOG_DEBUG(
 				"Un-gated front end for pipe %d\n", plane_id);
 	}
 }
@@ -550,7 +553,7 @@ static void reset_back_end_for_pipe(
 		struct dc_state *context)
 {
 	int i;
-
+	struct dc_context *ctx = dc->ctx;
 	if (pipe_ctx->stream_res.stream_enc == NULL) {
 		pipe_ctx->stream = NULL;
 		return;
@@ -596,8 +599,7 @@ static void reset_back_end_for_pipe(
 		return;
 
 	pipe_ctx->stream = NULL;
-	DC_LOG_DEBUG(dc->ctx->logger,
-					"Reset back end for pipe %d, tg:%d\n",
+	DC_LOG_DEBUG("Reset back end for pipe %d, tg:%d\n",
 					pipe_ctx->pipe_idx, pipe_ctx->stream_res.tg->inst);
 }
 
@@ -647,6 +649,7 @@ static void plane_atomic_power_down(stru
 {
 	struct dce_hwseq *hws = dc->hwseq;
 	struct dpp *dpp = pipe_ctx->plane_res.dpp;
+	struct dc_context *ctx = dc->ctx;
 
 	if (REG(DC_IP_REQUEST_CNTL)) {
 		REG_SET(DC_IP_REQUEST_CNTL, 0,
@@ -656,7 +659,7 @@ static void plane_atomic_power_down(stru
 		dpp->funcs->dpp_reset(dpp);
 		REG_SET(DC_IP_REQUEST_CNTL, 0,
 				IP_REQUEST_EN, 0);
-		DC_LOG_DEBUG(dc->ctx->logger,
+		DC_LOG_DEBUG(
 				"Power gated front end %d\n", pipe_ctx->pipe_idx);
 	}
 }
@@ -696,6 +699,8 @@ static void plane_atomic_disable(struct
 
 static void dcn10_disable_plane(struct dc *dc, struct pipe_ctx *pipe_ctx)
 {
+	struct dc_context *ctx = dc->ctx;
+
 	if (!pipe_ctx->plane_res.hubp || pipe_ctx->plane_res.hubp->power_gated)
 		return;
 
@@ -703,8 +708,7 @@ static void dcn10_disable_plane(struct d
 
 	apply_DEGVIDCN10_253_wa(dc);
 
-	DC_LOG_DC(dc->ctx->logger,
-					"Power down front end %d\n",
+	DC_LOG_DC("Power down front end %d\n",
 					pipe_ctx->pipe_idx);
 }
 
@@ -1932,6 +1936,7 @@ static void dcn10_apply_ctx_for_surface(
 	bool removed_pipe[4] = { false };
 	unsigned int ref_clk_mhz = dc->res_pool->ref_clock_inKhz/1000;
 	bool program_water_mark = false;
+	struct dc_context *ctx = dc->ctx;
 
 	struct pipe_ctx *top_pipe_to_program =
 			find_top_pipe_for_stream(dc, context, stream);
@@ -1983,7 +1988,7 @@ static void dcn10_apply_ctx_for_surface(
 			plane_atomic_disconnect(dc, old_pipe_ctx);
 			removed_pipe[i] = true;
 
-			DC_LOG_DC(dc->ctx->logger,
+			DC_LOG_DC(
 					"Reset mpcc for pipe %d\n",
 					old_pipe_ctx->pipe_idx);
 		}
--- a/drivers/gpu/drm/amd/display/dc/i2caux/aux_engine.c
+++ b/drivers/gpu/drm/amd/display/dc/i2caux/aux_engine.c
@@ -55,6 +55,8 @@ enum {
 
 #define FROM_ENGINE(ptr) \
 	container_of((ptr), struct aux_engine, base)
+#define DC_LOGGER \
+	engine->base.ctx->logger
 
 enum i2caux_engine_type dal_aux_engine_get_engine_type(
 	const struct engine *engine)
@@ -274,7 +276,7 @@ static bool read_command(
 
 	if (request->payload.address_space ==
 		I2CAUX_TRANSACTION_ADDRESS_SPACE_DPCD) {
-		DC_LOG_I2C_AUX(engine->base.ctx->logger,  "READ: addr:0x%x  value:0x%x Result:%d",
+		DC_LOG_I2C_AUX("READ: addr:0x%x  value:0x%x Result:%d",
 				request->payload.address,
 				request->payload.data[0],
 				ctx.operation_succeeded);
@@ -483,7 +485,7 @@ static bool write_command(
 
 	if (request->payload.address_space ==
 		I2CAUX_TRANSACTION_ADDRESS_SPACE_DPCD) {
-		DC_LOG_I2C_AUX(engine->base.ctx->logger,  "WRITE: addr:0x%x  value:0x%x Result:%d",
+		DC_LOG_I2C_AUX("WRITE: addr:0x%x  value:0x%x Result:%d",
 				request->payload.address,
 				request->payload.data[0],
 				ctx.operation_succeeded);
--- a/drivers/gpu/drm/amd/display/dc/i2caux/dce110/i2c_hw_engine_dce110.c
+++ b/drivers/gpu/drm/amd/display/dc/i2caux/dce110/i2c_hw_engine_dce110.c
@@ -48,6 +48,8 @@
 /*
  * This unit
  */
+#define DC_LOGGER \
+		hw_engine->base.base.base.ctx->logger
 
 enum dc_i2c_status {
 	DC_I2C_STATUS__DC_I2C_STATUS_IDLE,
@@ -525,9 +527,7 @@ static void construct(
 	REG_GET(MICROSECOND_TIME_BASE_DIV, XTAL_REF_DIV, &xtal_ref_div);
 
 	if (xtal_ref_div == 0) {
-		DC_LOG_WARNING(
-				hw_engine->base.base.base.ctx->logger,
-				"Invalid base timer divider\n",
+		DC_LOG_WARNING("Invalid base timer divider\n",
 				__func__);
 		xtal_ref_div = 2;
 	}
--- a/drivers/gpu/drm/amd/display/dc/irq/dce110/irq_service_dce110.c
+++ b/drivers/gpu/drm/amd/display/dc/irq/dce110/irq_service_dce110.c
@@ -36,6 +36,9 @@
 
 #include "dc.h"
 #include "core_types.h"
+#define DC_LOGGER \
+	irq_service->ctx->logger
+
 static bool hpd_ack(
 	struct irq_service *irq_service,
 	const struct irq_source_info *info)
@@ -181,9 +184,7 @@ bool dal_irq_service_dummy_set(
 	const struct irq_source_info *info,
 	bool enable)
 {
-	DC_LOG_ERROR(
-		irq_service->ctx->logger,
-		"%s: called for non-implemented irq source\n",
+	DC_LOG_ERROR("%s: called for non-implemented irq source\n",
 		__func__);
 	return false;
 }
@@ -192,9 +193,7 @@ bool dal_irq_service_dummy_ack(
 	struct irq_service *irq_service,
 	const struct irq_source_info *info)
 {
-	DC_LOG_ERROR(
-		irq_service->ctx->logger,
-		"%s: called for non-implemented irq source\n",
+	DC_LOG_ERROR("%s: called for non-implemented irq source\n",
 		__func__);
 	return false;
 }
--- a/drivers/gpu/drm/amd/display/dc/irq/irq_service.c
+++ b/drivers/gpu/drm/amd/display/dc/irq/irq_service.c
@@ -47,6 +47,8 @@
 
 #define CTX \
 		irq_service->ctx
+#define DC_LOGGER \
+	irq_service->ctx->logger
 
 void dal_irq_service_construct(
 	struct irq_service *irq_service,
@@ -104,9 +106,7 @@ bool dal_irq_service_set(
 		find_irq_source_info(irq_service, source);
 
 	if (!info) {
-		DC_LOG_ERROR(
-			irq_service->ctx->logger,
-			"%s: cannot find irq info table entry for %d\n",
+		DC_LOG_ERROR("%s: cannot find irq info table entry for %d\n",
 			__func__,
 			source);
 		return false;
@@ -142,9 +142,7 @@ bool dal_irq_service_ack(
 		find_irq_source_info(irq_service, source);
 
 	if (!info) {
-		DC_LOG_ERROR(
-			irq_service->ctx->logger,
-			"%s: cannot find irq info table entry for %d\n",
+		DC_LOG_ERROR("%s: cannot find irq info table entry for %d\n",
 			__func__,
 			source);
 		return false;
--- a/drivers/gpu/drm/amd/display/include/logger_types.h
+++ b/drivers/gpu/drm/amd/display/include/logger_types.h
@@ -29,38 +29,38 @@
 #include "os_types.h"
 
 #define MAX_NAME_LEN 32
-#define DC_LOG_ERROR(a, b, ...) dm_logger_write(a, LOG_ERROR, b, ## __VA_ARGS__)
-#define DC_LOG_WARNING(a, b, ...) dm_logger_write(a, LOG_WARNING, b, ## __VA_ARGS__)
-#define DC_LOG_DEBUG(a, b, ...) dm_logger_write(a, LOG_DEBUG, b, ## __VA_ARGS__)
-#define DC_LOG_DC(a, b, ...) dm_logger_write(a, LOG_DC, b, ## __VA_ARGS__)
-#define DC_LOG_DTN(a, b, ...) dm_logger_write(a, LOG_DTN, b, ## __VA_ARGS__)
-#define DC_LOG_SURFACE(a, b, ...) dm_logger_write(a, LOG_SURFACE, b, ## __VA_ARGS__)
-#define DC_LOG_HW_HOTPLUG(a, b, ...) dm_logger_write(a, LOG_HW_HOTPLUG, b, ## __VA_ARGS__)
-#define DC_LOG_HW_LINK_TRAINING(a, b, ...) dm_logger_write(a, LOG_HW_LINK_TRAINING, b, ## __VA_ARGS__)
-#define DC_LOG_HW_SET_MODE(a, b, ...) dm_logger_write(a, LOG_HW_SET_MODE, b, ## __VA_ARGS__)
-#define DC_LOG_HW_RESUME_S3(a, b, ...) dm_logger_write(a, LOG_HW_RESUME_S3, b, ## __VA_ARGS__)
-#define DC_LOG_HW_AUDIO(a, b, ...) dm_logger_write(a, LOG_HW_AUDIO, b, ## __VA_ARGS__)
-#define DC_LOG_HW_HPD_IRQ(a, b, ...) dm_logger_write(a, LOG_HW_HPD_IRQ, b, ## __VA_ARGS__)
-#define DC_LOG_MST(a, b, ...) dm_logger_write(a, LOG_MST, b, ## __VA_ARGS__)
-#define DC_LOG_SCALER(a, b, ...) dm_logger_write(a, LOG_SCALER, b, ## __VA_ARGS__)
-#define DC_LOG_BIOS(a, b, ...) dm_logger_write(a, LOG_BIOS, b, ## __VA_ARGS__)
-#define DC_LOG_BANDWIDTH_CALCS(a, b, ...) dm_logger_write(a, LOG_BANDWIDTH_CALCS, b, ## __VA_ARGS__)
-#define DC_LOG_BANDWIDTH_VALIDATION(a, b, ...) dm_logger_write(a, LOG_BANDWIDTH_VALIDATION, b, ## __VA_ARGS__)
-#define DC_LOG_I2C_AUX(a, b, ...) dm_logger_write(a, LOG_I2C_AUX, b, ## __VA_ARGS__)
-#define DC_LOG_SYNC(a, b, ...) dm_logger_write(a, LOG_SYNC, b, ## __VA_ARGS__)
-#define DC_LOG_BACKLIGHT(a, b, ...) dm_logger_write(a, LOG_BACKLIGHT, b, ## __VA_ARGS__)
-#define DC_LOG_FEATURE_OVERRIDE(a, b, ...) dm_logger_write(a, LOG_FEATURE_OVERRIDE, b, ## __VA_ARGS__)
-#define DC_LOG_DETECTION_EDID_PARSER(a, b, ...) dm_logger_write(a, LOG_DETECTION_EDID_PARSER, b, ## __VA_ARGS__)
-#define DC_LOG_DETECTION_DP_CAPS(a, b, ...) dm_logger_write(a, LOG_DETECTION_DP_CAPS, b, ## __VA_ARGS__)
-#define DC_LOG_RESOURCE(a, b, ...) dm_logger_write(a, LOG_RESOURCE, b, ## __VA_ARGS__)
-#define DC_LOG_DML(a, b, ...) dm_logger_write(a, LOG_DML, b, ## __VA_ARGS__)
-#define DC_LOG_EVENT_MODE_SET(a, b, ...) dm_logger_write(a, LOG_EVENT_MODE_SET, b, ## __VA_ARGS__)
-#define DC_LOG_EVENT_DETECTION(a, b, ...) dm_logger_write(a, LOG_EVENT_DETECTION, b, ## __VA_ARGS__)
-#define DC_LOG_EVENT_LINK_TRAINING(a, b, ...) dm_logger_write(a, LOG_EVENT_LINK_TRAINING, b, ## __VA_ARGS__)
-#define DC_LOG_EVENT_LINK_LOSS(a, b, ...) dm_logger_write(a, LOG_EVENT_LINK_LOSS, b, ## __VA_ARGS__)
-#define DC_LOG_EVENT_UNDERFLOW(a, b, ...) dm_logger_write(a, LOG_EVENT_UNDERFLOW, b, ## __VA_ARGS__)
-#define DC_LOG_IF_TRACE(a, b, ...) dm_logger_write(a, LOG_IF_TRACE, b, ## __VA_ARGS__)
-#define DC_LOG_PERF_TRACE(a, b, ...) dm_logger_write(a, LOG_PERF_TRACE, b, ## __VA_ARGS__)
+#define DC_LOG_ERROR(a, ...) dm_logger_write(DC_LOGGER, LOG_ERROR, a, ## __VA_ARGS__)
+#define DC_LOG_WARNING(a, ...) dm_logger_write(DC_LOGGER, LOG_WARNING, a, ## __VA_ARGS__)
+#define DC_LOG_DEBUG(a, ...) dm_logger_write(DC_LOGGER, LOG_DEBUG, a, ## __VA_ARGS__)
+#define DC_LOG_DC(a, ...) dm_logger_write(DC_LOGGER, LOG_DC, a, ## __VA_ARGS__)
+#define DC_LOG_DTN(a, ...) dm_logger_write(DC_LOGGER, LOG_DTN, a, ## __VA_ARGS__)
+#define DC_LOG_SURFACE(a, ...) dm_logger_write(DC_LOGGER, LOG_SURFACE, a, ## __VA_ARGS__)
+#define DC_LOG_HW_HOTPLUG(a, ...) dm_logger_write(DC_LOGGER, LOG_HW_HOTPLUG, a, ## __VA_ARGS__)
+#define DC_LOG_HW_LINK_TRAINING(a, ...) dm_logger_write(DC_LOGGER, LOG_HW_LINK_TRAINING, a, ## __VA_ARGS__)
+#define DC_LOG_HW_SET_MODE(a, ...) dm_logger_write(DC_LOGGER, LOG_HW_SET_MODE, a, ## __VA_ARGS__)
+#define DC_LOG_HW_RESUME_S3(a, ...) dm_logger_write(DC_LOGGER, LOG_HW_RESUME_S3, a, ## __VA_ARGS__)
+#define DC_LOG_HW_AUDIO(a, ...) dm_logger_write(DC_LOGGER, LOG_HW_AUDIO, a, ## __VA_ARGS__)
+#define DC_LOG_HW_HPD_IRQ(a, ...) dm_logger_write(DC_LOGGER, LOG_HW_HPD_IRQ, a, ## __VA_ARGS__)
+#define DC_LOG_MST(a, ...) dm_logger_write(DC_LOGGER, LOG_MST, a, ## __VA_ARGS__)
+#define DC_LOG_SCALER(a, ...) dm_logger_write(DC_LOGGER, LOG_SCALER, a, ## __VA_ARGS__)
+#define DC_LOG_BIOS(a, ...) dm_logger_write(DC_LOGGER, LOG_BIOS, a, ## __VA_ARGS__)
+#define DC_LOG_BANDWIDTH_CALCS(a, ...) dm_logger_write(DC_LOGGER, LOG_BANDWIDTH_CALCS, a, ## __VA_ARGS__)
+#define DC_LOG_BANDWIDTH_VALIDATION(a, ...) dm_logger_write(DC_LOGGER, LOG_BANDWIDTH_VALIDATION, a, ## __VA_ARGS__)
+#define DC_LOG_I2C_AUX(a, ...) dm_logger_write(DC_LOGGER, LOG_I2C_AUX, a, ## __VA_ARGS__)
+#define DC_LOG_SYNC(a, ...) dm_logger_write(DC_LOGGER, LOG_SYNC, a, ## __VA_ARGS__)
+#define DC_LOG_BACKLIGHT(a, ...) dm_logger_write(DC_LOGGER, LOG_BACKLIGHT, a, ## __VA_ARGS__)
+#define DC_LOG_FEATURE_OVERRIDE(a, ...) dm_logger_write(DC_LOGGER, LOG_FEATURE_OVERRIDE, a, ## __VA_ARGS__)
+#define DC_LOG_DETECTION_EDID_PARSER(a, ...) dm_logger_write(DC_LOGGER, LOG_DETECTION_EDID_PARSER, a, ## __VA_ARGS__)
+#define DC_LOG_DETECTION_DP_CAPS(a, ...) dm_logger_write(DC_LOGGER, LOG_DETECTION_DP_CAPS, a, ## __VA_ARGS__)
+#define DC_LOG_RESOURCE(a, ...) dm_logger_write(DC_LOGGER, LOG_RESOURCE, a, ## __VA_ARGS__)
+#define DC_LOG_DML(a, ...) dm_logger_write(DC_LOGGER, LOG_DML, a, ## __VA_ARGS__)
+#define DC_LOG_EVENT_MODE_SET(a, ...) dm_logger_write(DC_LOGGER, LOG_EVENT_MODE_SET, a, ## __VA_ARGS__)
+#define DC_LOG_EVENT_DETECTION(a, ...) dm_logger_write(DC_LOGGER, LOG_EVENT_DETECTION, a, ## __VA_ARGS__)
+#define DC_LOG_EVENT_LINK_TRAINING(a, ...) dm_logger_write(DC_LOGGER, LOG_EVENT_LINK_TRAINING, a, ## __VA_ARGS__)
+#define DC_LOG_EVENT_LINK_LOSS(a, ...) dm_logger_write(DC_LOGGER, LOG_EVENT_LINK_LOSS, a, ## __VA_ARGS__)
+#define DC_LOG_EVENT_UNDERFLOW(a, ...) dm_logger_write(DC_LOGGER, LOG_EVENT_UNDERFLOW, a, ## __VA_ARGS__)
+#define DC_LOG_IF_TRACE(a, ...) dm_logger_write(DC_LOGGER, LOG_IF_TRACE, a, ## __VA_ARGS__)
+#define DC_LOG_PERF_TRACE(a, ...) dm_logger_write(DC_LOGGER, LOG_PERF_TRACE, a, ## __VA_ARGS__)
 
 
 struct dal_logger;
