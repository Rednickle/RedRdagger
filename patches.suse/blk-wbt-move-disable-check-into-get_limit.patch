From ffa358dcaae1f2f00926484e712e06daa8953cb4 Mon Sep 17 00:00:00 2001
From: Jens Axboe <axboe@kernel.dk>
Date: Mon, 20 Aug 2018 13:24:25 -0600
Subject: [PATCH] blk-wbt: move disable check into get_limit()
Git-commit: ffa358dcaae1f2f00926484e712e06daa8953cb4
Patch-mainline: v4.19-rc1
References: bsc#1135873

Check it in one place, instead of in multiple places.

Tested-by: Anchal Agarwal <anchalag@amazon.com>
Signed-off-by: Jens Axboe <axboe@kernel.dk>
Acked-by: Jan Kara <jack@suse.cz>

---
 block/blk-wbt.c |   23 +++++++----------------
 1 file changed, 7 insertions(+), 16 deletions(-)

--- a/block/blk-wbt.c
+++ b/block/blk-wbt.c
@@ -481,6 +481,13 @@ static inline unsigned int get_limit(str
 {
 	unsigned int limit;
 
+	/*
+	 * If we got disabled, just return UINT_MAX. This ensures that
+	 * we'll properly inc a new IO, and dec+wakeup at the end.
+	 */
+	if (!rwb_enabled(rwb))
+		return UINT_MAX;
+
 	if ((rw & REQ_OP_MASK) == REQ_OP_DISCARD)
 		return rwb->wb_background;
 
@@ -545,16 +545,6 @@ static void __wbt_wait(struct rq_wb *rwb
 	struct rq_wait *rqw = get_rq_wait(rwb, wb_acct);
 	DECLARE_WAITQUEUE(wait, current);
 
-	/*
-	 * inc it here even if disabled, since we'll dec it at completion.
-	 * this only happens if the task was sleeping in __wbt_wait(),
-	 * and someone turned it off at the same time.
-	 */
-	if (!rwb_enabled(rwb)) {
-		atomic_inc(&rqw->inflight);
-		return;
-	}
-
 	if (!waitqueue_active(&rqw->wait)
 			&& atomic_inc_below(&rqw->inflight, get_limit(rwb, rw)))
 		return;
@@ -563,11 +553,6 @@ static void __wbt_wait(struct rq_wb *rwb
 	do {
 		set_current_state(TASK_UNINTERRUPTIBLE);
 
-		if (!rwb_enabled(rwb)) {
-			atomic_inc(&rqw->inflight);
-			break;
-		}
-
 		if (atomic_inc_below(&rqw->inflight, get_limit(rwb, rw)))
 			break;
 
