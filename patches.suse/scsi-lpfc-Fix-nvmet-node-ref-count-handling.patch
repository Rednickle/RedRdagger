From: James Smart <jsmart2021@gmail.com>
Date: Thu, 1 Jun 2017 21:07:00 -0700
Subject: scsi: lpfc: Fix nvmet node ref count handling
Patch-mainline: v4.13-rc1
Git-commit: 6599e12428a8b3b182e91818cb7b73ab29e7daff
References: bsc#1050239,FATE#322918

When unloading the driver, the NVMET driver would wait the full 30
seconds for its UNMAPPED initiator node to get removed before continuing
with the unload process.  NVMEI worked correctly.

For each rport put into UNMAPPED or MAPPED state by NVMET, the driver
puts a reference on the NDLP.  The difference is that NVMEI has a
unregister call for its rports and the extra reference is removed in the
unregister process.  For NVMET, the driver has to remove the reference
explicitly when dropping out of UNMAPPED or MAPPED because there is no
unregister call.

Add a call to lpfc_nlp_put on the ndlp when NVMET and the old state was
UNMAPPED or MAPPED.

Signed-off-by: Dick Kennedy <dick.kennedy@broadcom.com>
Signed-off-by: James Smart <james.smart@broadcom.com>
Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
Acked-by: Johannes Thumshirn <jthumshirn@suse.de>
---
 drivers/scsi/lpfc/lpfc_hbadisc.c |    8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

--- a/drivers/scsi/lpfc/lpfc_hbadisc.c
+++ b/drivers/scsi/lpfc/lpfc_hbadisc.c
@@ -4167,14 +4167,14 @@ lpfc_nlp_state_cleanup(struct lpfc_vport
 			lpfc_unregister_remote_port(ndlp);
 		}
 
-		/* Notify the NVME transport of this rport's loss on the
-		 * Initiator.  For NVME Target, should upcall transport
-		 * in the else clause when API available.
-		 */
 		if (ndlp->nlp_fc4_type & NLP_FC4_NVME) {
 			vport->phba->nport_event_cnt++;
 			if (vport->phba->nvmet_support == 0)
+				/* Start devloss */
 				lpfc_nvme_unregister_port(vport, ndlp);
+			else
+				/* NVMET has no upcall. */
+				lpfc_nlp_put(ndlp);
 		}
 	}
 
