From: Dmitry Safonov <dima@arista.com>
Date: Thu, 1 Nov 2018 00:24:52 +0000
Subject: tty/ldsem: Decrement wait_readers on timeouted down_read()
Patch-mainline: Submitted on 2018/11/1
References: bnc#1105428

It seems like when ldsem_down_read() fails with timeout, it misses
update for sem->wait_readers. By that reason, when writer finally
releases write end of the semaphore __ldsem_wake_readers() does adjust
sem->count with wrong value:
sem->wait_readers * (LDSEM_ACTIVE_BIAS - LDSEM_WAIT_BIAS)

I.e, if update comes with 1 missed wait_readers decrement, sem->count
will be 0x100000001 which means that there is active reader and it'll
make any further writer to fail in acquiring the semaphore.

It looks like, this is a dead-code, because ldsem_down_read() is never
called with timeout different than MAX_SCHEDULE_TIMEOUT, so it might be
worth to delete timeout parameter and error path fall-back..

Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Cc: Jiri Slaby <jslaby@suse.com>
Signed-off-by: Dmitry Safonov <dima@arista.com>
Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 drivers/tty/tty_ldsem.c |    1 +
 1 file changed, 1 insertion(+)

--- a/drivers/tty/tty_ldsem.c
+++ b/drivers/tty/tty_ldsem.c
@@ -228,6 +228,7 @@ down_read_failed(struct ld_semaphore *se
 		raw_spin_lock_irq(&sem->wait_lock);
 		if (waiter.task) {
 			ldsem_atomic_update(-LDSEM_WAIT_BIAS, sem);
+			sem->wait_readers--;
 			list_del(&waiter.list);
 			raw_spin_unlock_irq(&sem->wait_lock);
 			put_task_struct(waiter.task);
