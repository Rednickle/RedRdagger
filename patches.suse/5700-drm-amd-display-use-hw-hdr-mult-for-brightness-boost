From: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
Date: Fri, 23 Feb 2018 17:51:33 -0500
Subject: drm/amd/display: use HW hdr mult for brightness boost
Git-commit: a4056c2a6344c64bd62234458a314e6aecce226f
Patch-mainline: v4.17-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

In MPO scenario when playing SDR clip in HDR desktop mode, Win is
boosting desktop and requests driver to boost MPO. But driver boosting
is currently done in regamma which is stream property and thus shared
between grph and video.

Redesigning the boosting in RV: use CM_HDR_MULT register which was added
for this scenario. It also has the benefit that it can be done in HIRQL.

Signed-off-by: Krunoslav Kovac <Krunoslav.Kovac@amd.com>
Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/amd/display/dc/core/dc.c                  |    3 --
 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c          |    1 
 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.h          |   16 ++++++++---
 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c       |    9 ++++++
 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c |   20 ++++++++++++++
 drivers/gpu/drm/amd/display/dc/inc/hw/dpp.h               |    3 ++
 6 files changed, 45 insertions(+), 7 deletions(-)

--- a/drivers/gpu/drm/amd/display/dc/core/dc.c
+++ b/drivers/gpu/drm/amd/display/dc/core/dc.c
@@ -1110,9 +1110,6 @@ static enum surface_update_type get_plan
 	if (u->plane_info->input_tf != u->surface->input_tf)
 		update_flags->bits.input_tf_change = 1;
 
-	if (u->plane_info->sdr_white_level != u->surface->sdr_white_level)
-		update_flags->bits.output_tf_change = 1;
-
 	if (u->plane_info->horizontal_mirror != u->surface->horizontal_mirror)
 		update_flags->bits.horizontal_mirror_change = 1;
 
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.c
@@ -464,6 +464,7 @@ static const struct dpp_funcs dcn10_dpp_
 		.set_cursor_attributes = dpp1_set_cursor_attributes,
 		.set_cursor_position = dpp1_set_cursor_position,
 		.dpp_dppclk_control = dpp1_dppclk_control,
+		.dpp_set_hdr_multiplier = dpp1_set_hdr_multiplier,
 };
 
 static struct dpp_caps dcn10_dpp_cap = {
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.h
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp.h
@@ -113,7 +113,8 @@
 	SRI(CURSOR0_CONTROL, CNVC_CUR, id), \
 	SRI(CURSOR0_COLOR0, CNVC_CUR, id), \
 	SRI(CURSOR0_COLOR1, CNVC_CUR, id), \
-	SRI(DPP_CONTROL, DPP_TOP, id)
+	SRI(DPP_CONTROL, DPP_TOP, id), \
+	SRI(CM_HDR_MULT_COEF, CM, id)
 
 
 
@@ -308,7 +309,8 @@
 	TF_SF(CNVC_CUR0_CURSOR0_CONTROL, CUR0_ENABLE, mask_sh), \
 	TF_SF(CNVC_CUR0_CURSOR0_COLOR0, CUR0_COLOR0, mask_sh), \
 	TF_SF(CNVC_CUR0_CURSOR0_COLOR1, CUR0_COLOR1, mask_sh), \
-	TF_SF(DPP_TOP0_DPP_CONTROL, DPP_CLOCK_ENABLE, mask_sh)
+	TF_SF(DPP_TOP0_DPP_CONTROL, DPP_CLOCK_ENABLE, mask_sh), \
+	TF_SF(CM0_CM_HDR_MULT_COEF, CM_HDR_MULT_COEF, mask_sh)
 
 #define TF_REG_LIST_SH_MASK_DCN10(mask_sh)\
 	TF_REG_LIST_SH_MASK_DCN(mask_sh),\
@@ -1012,7 +1014,8 @@
 	type CUR0_COLOR0; \
 	type CUR0_COLOR1; \
 	type DPPCLK_RATE_CONTROL; \
-	type DPP_CLOCK_ENABLE;
+	type DPP_CLOCK_ENABLE; \
+	type CM_HDR_MULT_COEF;
 
 struct dcn_dpp_shift {
 	TF_REG_FIELD_LIST(uint8_t)
@@ -1258,7 +1261,8 @@ struct dcn_dpp_mask {
 	uint32_t CURSOR0_CONTROL; \
 	uint32_t CURSOR0_COLOR0; \
 	uint32_t CURSOR0_COLOR1; \
-	uint32_t DPP_CONTROL;
+	uint32_t DPP_CONTROL; \
+	uint32_t CM_HDR_MULT_COEF;
 
 struct dcn_dpp_registers {
 	DPP_COMMON_REG_VARIABLE_LIST
@@ -1414,6 +1418,10 @@ void dpp1_dppclk_control(
 		bool dppclk_div,
 		bool enable);
 
+void dpp1_set_hdr_multiplier(
+		struct dpp *dpp_base,
+		uint32_t multiplier);
+
 void dpp1_construct(struct dcn10_dpp *dpp1,
 	struct dc_context *ctx,
 	uint32_t inst,
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_dpp_cm.c
@@ -804,3 +804,12 @@ void dpp1_program_input_lut(
 	REG_UPDATE(CM_IGAM_CONTROL, CM_IGAM_LUT_MODE, rama_occupied ? 3 : 2);
 	REG_GET(CM_IGAM_CONTROL, CM_IGAM_LUT_MODE, &ram_num);
 }
+
+void dpp1_set_hdr_multiplier(
+		struct dpp *dpp_base,
+		uint32_t multiplier)
+{
+	struct dcn10_dpp *dpp = TO_DCN10_DPP(dpp_base);
+
+	REG_UPDATE(CM_HDR_MULT_COEF, CM_HDR_MULT_COEF, multiplier);
+}
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -1835,6 +1835,24 @@ static void dcn10_otg_blank(
 	}
 }
 
+static void set_hdr_multiplier(struct pipe_ctx *pipe_ctx)
+{
+	struct fixed31_32 multiplier = dal_fixed31_32_from_fraction(
+			pipe_ctx->plane_state->sdr_white_level, 80);
+	uint32_t hw_mult = 0x1f000; // 1.0 default multiplier
+	struct custom_float_format fmt;
+
+	fmt.exponenta_bits = 6;
+	fmt.mantissa_bits = 12;
+	fmt.sign = true;
+
+	if (pipe_ctx->plane_state->sdr_white_level > 80)
+		convert_to_custom_float_format(multiplier, &fmt, &hw_mult);
+
+	pipe_ctx->plane_res.dpp->funcs->dpp_set_hdr_multiplier(
+			pipe_ctx->plane_res.dpp, hw_mult);
+}
+
 static void program_all_pipe_in_tree(
 		struct dc *dc,
 		struct pipe_ctx *pipe_ctx,
@@ -1862,6 +1880,8 @@ static void program_all_pipe_in_tree(
 
 		update_dchubp_dpp(dc, pipe_ctx, context);
 
+		set_hdr_multiplier(pipe_ctx);
+
 		if (pipe_ctx->plane_state->update_flags.bits.full_update ||
 				pipe_ctx->plane_state->update_flags.bits.in_transfer_func_change ||
 				pipe_ctx->plane_state->update_flags.bits.gamma_change)
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/dpp.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/dpp.h
@@ -132,6 +132,9 @@ struct dpp_funcs {
 			const struct dc_cursor_mi_param *param,
 			uint32_t width
 			);
+	void (*dpp_set_hdr_multiplier)(
+			struct dpp *dpp_base,
+			uint32_t multiplier);
 
 	void (*dpp_dppclk_control)(
 			struct dpp *dpp_base,
