From: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Date: Tue, 13 Mar 2018 15:00:20 -0400
Subject: drm/amd/display: align dtn logs and add mpc idle bit print
Git-commit: a052a516de4c3e46f2e442ec118c391dbf9932e3
Patch-mainline: v4.18-rc1
References: FATE#326289 FATE#326079 FATE#326049 FATE#322398 FATE#326166

Signed-off-by: Dmytro Laktyushkin <Dmytro.Laktyushkin@amd.com>
Reviewed-by: Tony Cheng <Tony.Cheng@amd.com>
Acked-by: Harry Wentland <harry.wentland@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
Acked-by: Petr Tesarik <ptesarik@suse.com>
---
 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c |   53 ++++++--------
 drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c          |    4 -
 drivers/gpu/drm/amd/display/dc/inc/hw/mpc.h               |    2 
 3 files changed, 28 insertions(+), 31 deletions(-)

--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_hw_sequencer.c
@@ -56,16 +56,17 @@
 #define FN(reg_name, field_name) \
 	hws->shifts->field_name, hws->masks->field_name
 
+/*print is 17 wide, first two characters are spaces*/
 #define DTN_INFO_MICRO_SEC(ref_cycle) \
 	print_microsec(dc_ctx, ref_cycle)
 
 void print_microsec(struct dc_context *dc_ctx, uint32_t ref_cycle)
 {
-	static const uint32_t ref_clk_mhz = 48;
-	static const unsigned int frac = 10;
+	const uint32_t ref_clk_mhz = dc_ctx->dc->res_pool->ref_clock_inKhz / 1000;
+	static const unsigned int frac = 1000;
 	uint32_t us_x10 = (ref_cycle * frac) / ref_clk_mhz;
 
-	DTN_INFO("%d.%d \t ",
+	DTN_INFO("  %11d.%03d",
 			us_x10 / frac,
 			us_x10 % frac);
 }
@@ -92,14 +93,14 @@ void dcn10_log_hubbub_state(struct dc *d
 
 	hubbub1_wm_read_state(dc->res_pool->hubbub, &wm);
 
-	DTN_INFO("HUBBUB WM: \t data_urgent \t pte_meta_urgent \t "
-			"sr_enter \t sr_exit \t dram_clk_change \n");
+	DTN_INFO("HUBBUB WM:      data_urgent  pte_meta_urgent"
+			"         sr_enter          sr_exit  dram_clk_change\n");
 
 	for (i = 0; i < 4; i++) {
 		struct dcn_hubbub_wm_set *s;
 
 		s = &wm.sets[i];
-		DTN_INFO("WM_Set[%d]:\t ", s->wm_set);
+		DTN_INFO("WM_Set[%d]:", s->wm_set);
 		DTN_INFO_MICRO_SEC(s->data_urgent);
 		DTN_INFO_MICRO_SEC(s->pte_meta_urgent);
 		DTN_INFO_MICRO_SEC(s->sr_enter);
@@ -121,19 +122,17 @@ void dcn10_log_hw_state(struct dc *dc)
 
 	dcn10_log_hubbub_state(dc);
 
-	DTN_INFO("HUBP:  format  addr_hi  width  height  "
-			"rotation  mirror  sw_mode  "
-			"dcc_en  blank_en  ttu_dis  underflow  "
-			"min_ttu_vblank  qos_low_wm  qos_high_wm\n");
+	DTN_INFO("HUBP:  format  addr_hi  width  height"
+			"  rot  mir  sw_mode  dcc_en  blank_en  ttu_dis  underflow"
+			"   min_ttu_vblank       qos_low_wm      qos_high_wm\n");
 	for (i = 0; i < pool->pipe_count; i++) {
 		struct hubp *hubp = pool->hubps[i];
 		struct dcn_hubp_state s;
 
 		hubp1_read_state(TO_DCN10_HUBP(hubp), &s);
 
-		DTN_INFO("[%-2d]:  %5xh  %6xh  %5d  %6d  "
-				"%7xh  %5xh  %6xh  "
-				"%6d  %8d  %7d  %8xh \t",
+		DTN_INFO("[%2d]:  %5xh  %6xh  %5d  %6d  %2xh  %2xh  %6xh"
+				"  %6d  %8d  %7d  %8xh",
 				hubp->inst,
 				s.pixel_format,
 				s.inuse_addr_hi,
@@ -152,25 +151,21 @@ void dcn10_log_hw_state(struct dc *dc)
 		DTN_INFO("\n");
 	}
 	DTN_INFO("\n");
+
+	DTN_INFO("MPCC:  OPP  DPP  MPCCBOT  MODE  ALPHA_MODE  PREMULT  OVERLAP_ONLY  IDLE\n");
 	for (i = 0; i < pool->pipe_count; i++) {
-		struct output_pixel_processor *opp = pool->opps[i];
-		struct mpcc *mpcc = opp->mpc_tree_params.opp_list;
 		struct mpcc_state s = {0};
 
-		while (mpcc) {
-			ASSERT(opp->mpc_tree_params.opp_id == opp->inst);
-			pool->mpc->funcs->read_mpcc_state(pool->mpc, mpcc->mpcc_id, &s);
-			DTN_INFO("[OPP%d - MPCC%d]: DPP%d MPCCBOT%x MODE:%d ALPHA_MODE:%d PREMULT:%d OVERLAP_ONLY:%d\n",
-				s.opp_id, mpcc->mpcc_id, s.dpp_id, s.bot_mpcc_id,
-				s.mode, s.alpha_mode, s.pre_multiplied_alpha, s.overlap_only);
-			mpcc = mpcc->mpcc_bot;
-			ASSERT(!mpcc || mpcc->mpcc_id == s.bot_mpcc_id);
-		}
+		pool->mpc->funcs->read_mpcc_state(pool->mpc, i, &s);
+		DTN_INFO("[%2d]:  %2xh  %2xh  %6xh  %4d  %10d  %7d  %12d  %4d\n",
+			i, s.opp_id, s.dpp_id, s.bot_mpcc_id,
+			s.mode, s.alpha_mode, s.pre_multiplied_alpha, s.overlap_only,
+			s.idle);
 	}
 	DTN_INFO("\n");
 
-	DTN_INFO("OTG:\t v_bs \t v_be \t v_ss \t v_se \t vpol \t vmax \t vmin \t "
-			"h_bs \t h_be \t h_ss \t h_se \t hpol \t htot \t vtot \t underflow\n");
+	DTN_INFO("OTG:  v_bs  v_be  v_ss  v_se  vpol  vmax  vmin"
+			"  h_bs  h_be  h_ss  h_se  hpol  htot  vtot  underflow\n");
 
 	for (i = 0; i < pool->timing_generator_count; i++) {
 		struct timing_generator *tg = pool->timing_generators[i];
@@ -182,9 +177,8 @@ void dcn10_log_hw_state(struct dc *dc)
 		if ((s.otg_enabled & 1) == 0)
 			continue;
 
-		DTN_INFO("[%d]:\t %d \t %d \t %d \t %d \t "
-				"%d \t %d \t %d \t %d \t %d \t %d \t "
-				"%d \t %d \t %d \t %d \t %d \t ",
+		DTN_INFO("[%d]: %5d %5d %5d %5d %5d %5d %5d %5d %5d %5d"
+				" %5d %5d %5d %5d  %9d\n",
 				tg->inst,
 				s.v_blank_start,
 				s.v_blank_end,
@@ -201,7 +195,6 @@ void dcn10_log_hw_state(struct dc *dc)
 				s.h_total,
 				s.v_total,
 				s.underflow_occurred_status);
-		DTN_INFO("\n");
 	}
 	DTN_INFO("\n");
 
--- a/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
+++ b/drivers/gpu/drm/amd/display/dc/dcn10/dcn10_mpc.c
@@ -422,7 +422,9 @@ void mpc1_read_mpcc_state(
 	REG_GET_4(MPCC_CONTROL[mpcc_inst], MPCC_MODE, &s->mode,
 			MPCC_ALPHA_BLND_MODE, &s->alpha_mode,
 			MPCC_ALPHA_MULTIPLIED_MODE, &s->pre_multiplied_alpha,
-			MPCC_BLND_ACTIVE_OVERLAP_ONLY, &s->pre_multiplied_alpha);
+			MPCC_BLND_ACTIVE_OVERLAP_ONLY, &s->overlap_only);
+	REG_GET_2(MPCC_STATUS[mpcc_inst], MPCC_IDLE, &s->idle,
+			MPCC_BUSY, &s->busy);
 }
 
 const struct mpc_funcs dcn10_mpc_funcs = {
--- a/drivers/gpu/drm/amd/display/dc/inc/hw/mpc.h
+++ b/drivers/gpu/drm/amd/display/dc/inc/hw/mpc.h
@@ -113,6 +113,8 @@ struct mpcc_state {
 	uint32_t alpha_mode;
 	uint32_t pre_multiplied_alpha;
 	uint32_t overlap_only;
+	uint32_t idle;
+	uint32_t busy;
 };
 
 struct mpc_funcs {
