From: Chuck Lever <chuck.lever@oracle.com>
Date: Tue, 1 May 2018 11:37:14 -0400
Subject: [PATCH] xprtrdma: Fix list corruption / DMAR errors during MR
 recovery
Git-commit: 054f155721d7af1f343ed52bea246626d8450ca8
Patch-mainline: v4.17-rc5
References: git-fixes

The ro_release_mr methods check whether mr->mr_list is empty.
Therefore, be sure to always use list_del_init when removing an MR
linked into a list using that field. Otherwise, when recovering from
transport failures or device removal, list corruption can result, or
MRs can get mapped or unmapped an odd number of times, resulting in
IOMMU-related failures.

In general this fix is appropriate back to v4.8. However, code
changes since then make it impossible to apply this patch directly
to stable kernels. The fix would have to be applied by hand or
reworked for kernels earlier than v4.16.

Backport guidance -- there are several cases:
- When creating an MR, initialize mr_list so that using list_empty
  on an as-yet-unused MR is safe.
- When an MR is being handled by the remote invalidation path,
  ensure that mr_list is reinitialized when it is removed from
  rl_registered.
- When an MR is being handled by rpcrdma_destroy_mrs, it is removed
  from mr_all, but it may still be on an rl_registered list. In
  that case, the MR needs to be removed from that list before being
  released.
- Other cases are covered by using list_del_init in rpcrdma_mr_pop.

Fixes: 9d6b04097882 ('xprtrdma: Place registered MWs on a ... ')
Signed-off-by: Chuck Lever <chuck.lever@oracle.com>
Signed-off-by: Anna Schumaker <Anna.Schumaker@Netapp.com>
Acked-by: NeilBrown <neilb@suse.com>

---
 net/sunrpc/xprtrdma/fmr_ops.c   |    5 +----
 net/sunrpc/xprtrdma/frwr_ops.c  |    9 +++------
 net/sunrpc/xprtrdma/verbs.c     |    5 +++++
 net/sunrpc/xprtrdma/xprt_rdma.h |    2 +-
 4 files changed, 10 insertions(+), 11 deletions(-)

--- a/net/sunrpc/xprtrdma/fmr_ops.c
+++ b/net/sunrpc/xprtrdma/fmr_ops.c
@@ -71,6 +71,7 @@ fmr_op_init_mr(struct rpcrdma_ia *ia, st
 	if (IS_ERR(mw->fmr.fm_mr))
 		goto out_fmr_err;
 
+	INIT_LIST_HEAD(&mw->mw_list);
 	return 0;
 
 out_fmr_err:
@@ -101,10 +102,6 @@ fmr_op_release_mr(struct rpcrdma_mw *r)
 	LIST_HEAD(unmap_list);
 	int rc;
 
-	/* Ensure MW is not on any rl_registered list */
-	if (!list_empty(&r->mw_list))
-		list_del(&r->mw_list);
-
 	kfree(r->fmr.fm_physaddrs);
 	kfree(r->mw_sg);
 
--- a/net/sunrpc/xprtrdma/frwr_ops.c
+++ b/net/sunrpc/xprtrdma/frwr_ops.c
@@ -109,6 +109,7 @@ frwr_op_init_mr(struct rpcrdma_ia *ia, s
 	if (!r->mw_sg)
 		goto out_list_err;
 
+	INIT_LIST_HEAD(&r->mw_list);
 	sg_init_table(r->mw_sg, depth);
 	init_completion(&f->fr_linv_done);
 	return 0;
@@ -132,10 +133,6 @@ frwr_op_release_mr(struct rpcrdma_mw *r)
 {
 	int rc;
 
-	/* Ensure MW is not on any rl_registered list */
-	if (!list_empty(&r->mw_list))
-		list_del(&r->mw_list);
-
 	rc = ib_dereg_mr(r->frmr.fr_mr);
 	if (rc)
 		pr_err("rpcrdma: final ib_dereg_mr for %p returned %i\n",
@@ -192,11 +189,11 @@ frwr_op_recover_mr(struct rpcrdma_mw *mw
 	return;
 
 out_release:
-	pr_err("rpcrdma: FRMR reset failed %d, %p release\n", rc, mw);
+	pr_err("rpcrdma: FRMR reset failed %d, %p released\n", rc, mw);
 	r_xprt->rx_stats.mrs_orphaned++;
 
 	spin_lock(&r_xprt->rx_buf.rb_mwlock);
-	list_del(&mw->mw_all);
+	list_del_init(&mw->mw_all);
 	spin_unlock(&r_xprt->rx_buf.rb_mwlock);
 
 	frwr_op_release_mr(mw);
--- a/net/sunrpc/xprtrdma/verbs.c
+++ b/net/sunrpc/xprtrdma/verbs.c
@@ -1143,6 +1143,11 @@ rpcrdma_destroy_mrs(struct rpcrdma_buffe
 		list_del(&mw->mw_all);
 
 		spin_unlock(&buf->rb_mwlock);
+
+		/* Ensure MW is not on any rl_registered list */
+		if (!list_empty(&mw->mw_list))
+			list_del(&mw->mw_list);
+
 		ia->ri_ops->ro_release_mr(mw);
 		count++;
 		spin_lock(&buf->rb_mwlock);
--- a/net/sunrpc/xprtrdma/xprt_rdma.h
+++ b/net/sunrpc/xprtrdma/xprt_rdma.h
@@ -384,7 +384,7 @@ rpcrdma_pop_mw(struct list_head *list)
 	struct rpcrdma_mw *mw;
 
 	mw = list_first_entry(list, struct rpcrdma_mw, mw_list);
-	list_del(&mw->mw_list);
+	list_del_init(&mw->mw_list);
 	return mw;
 }
 
